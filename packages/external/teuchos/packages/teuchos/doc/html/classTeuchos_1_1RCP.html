<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Teuchos - Trilinos Tools Package: Teuchos::RCP&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Teuchos - Trilinos Tools Package
   &#160;<span id="projectnumber">Version of the Day</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTeuchos.html">Teuchos</a></li><li class="navelem"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classTeuchos_1_1RCP-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Teuchos::RCP&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__teuchos__mem__mng__grp.html">Teuchos Memory Management Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Smart reference counting pointer class for automatic garbage collection.  
 <a href="classTeuchos_1_1RCP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5718fa8c455b445078632723c8666480"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a5718fa8c455b445078632723c8666480">element_type</a></td></tr>
<tr class="separator:a5718fa8c455b445078632723c8666480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3e9fabd5a8558882ea4a14dde9f82df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aa3e9fabd5a8558882ea4a14dde9f82df">RCP</a> (T *p, ERCPWeakNoDealloc)</td></tr>
<tr class="memdesc:aa3e9fabd5a8558882ea4a14dde9f82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> from a raw pointer to a type that <em>is</em> defined.  <a href="#aa3e9fabd5a8558882ea4a14dde9f82df">More...</a><br /></td></tr>
<tr class="separator:aa3e9fabd5a8558882ea4a14dde9f82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16286f0170a5ae6c7c2327ab12c681cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a16286f0170a5ae6c7c2327ab12c681cc">RCP</a> (T *p, ERCPUndefinedWeakNoDealloc)</td></tr>
<tr class="memdesc:a16286f0170a5ae6c7c2327ab12c681cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> from a raw pointer to a type that is <em>not</em> defined.  <a href="#a16286f0170a5ae6c7c2327ab12c681cc">More...</a><br /></td></tr>
<tr class="separator:a16286f0170a5ae6c7c2327ab12c681cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9388b91f32514229024f6a108d64529"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T &gt; </td></tr>
<tr class="memitem:ae9388b91f32514229024f6a108d64529"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae9388b91f32514229024f6a108d64529">RCP</a> (T *p, Dealloc_T dealloc, ERCPUndefinedWithDealloc, bool <a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e">has_ownership</a>=true)</td></tr>
<tr class="memdesc:ae9388b91f32514229024f6a108d64529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer and a custom deallocator for an undefined type.  <a href="#ae9388b91f32514229024f6a108d64529">More...</a><br /></td></tr>
<tr class="separator:ae9388b91f32514229024f6a108d64529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/destructors/initializers.</div></td></tr>
<tr class="memitem:a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac">RCP</a> (<a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a> null_arg=null)</td></tr>
<tr class="memdesc:a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <code>RCP&lt;T&gt;</code> to NULL.  <a href="#a6df5f0ec485e775f8d35bfdd2dbb0eac">More...</a><br /></td></tr>
<tr class="separator:a6df5f0ec485e775f8d35bfdd2dbb0eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aca5aaa0a0ee98f43a178e28ca5ade6b1">RCP</a> (T *p, bool <a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e">has_ownership</a>=true)</td></tr>
<tr class="memdesc:aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer.  <a href="#aca5aaa0a0ee98f43a178e28ca5ade6b1">More...</a><br /></td></tr>
<tr class="separator:aca5aaa0a0ee98f43a178e28ca5ade6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T &gt; </td></tr>
<tr class="memitem:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab7153f6d53b495afd4c1a4a45d9710d4">RCP</a> (T *p, Dealloc_T dealloc, bool <a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e">has_ownership</a>)</td></tr>
<tr class="memdesc:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a raw pointer and a custom deallocator.  <a href="#ab7153f6d53b495afd4c1a4a45d9710d4">More...</a><br /></td></tr>
<tr class="separator:ab7153f6d53b495afd4c1a4a45d9710d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8711f68aa09dcaf4756aa19949d2d44a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8711f68aa09dcaf4756aa19949d2d44a">RCP</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;r_ptr)</td></tr>
<tr class="memdesc:a8711f68aa09dcaf4756aa19949d2d44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from another <code>RCP&lt;T&gt;</code> object.  <a href="#a8711f68aa09dcaf4756aa19949d2d44a">More...</a><br /></td></tr>
<tr class="separator:a8711f68aa09dcaf4756aa19949d2d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c3e448a0ec56fe6176508c43e51c66"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ab1c3e448a0ec56fe6176508c43e51c66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab1c3e448a0ec56fe6176508c43e51c66">RCP</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;r_ptr)</td></tr>
<tr class="memdesc:ab1c3e448a0ec56fe6176508c43e51c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from another <code>RCP&lt;T2&gt;</code> object (implicit conversion only).  <a href="#ab1c3e448a0ec56fe6176508c43e51c66">More...</a><br /></td></tr>
<tr class="separator:ab1c3e448a0ec56fe6176508c43e51c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b">~RCP</a> ()</td></tr>
<tr class="memdesc:a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a reference to a dynamically allocated object and possibly deletes the object if owned.  <a href="#a32c1a9a58e67a6d0a3fbdbb86bf8701b">More...</a><br /></td></tr>
<tr class="separator:a32c1a9a58e67a6d0a3fbdbb86bf8701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3bf10956b92aeebe3bf42a37d7d05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aed3bf10956b92aeebe3bf42a37d7d05f">operator=</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;r_ptr)</td></tr>
<tr class="memdesc:aed3bf10956b92aeebe3bf42a37d7d05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the pointer to the referenced object and increment the reference count.  <a href="#aed3bf10956b92aeebe3bf42a37d7d05f">More...</a><br /></td></tr>
<tr class="separator:aed3bf10956b92aeebe3bf42a37d7d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a9f6fd39aa3520c4b4c7a1ca733ff07f9">operator=</a> (<a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to null.  <a href="#a9f6fd39aa3520c4b4c7a1ca733ff07f9">More...</a><br /></td></tr>
<tr class="separator:a9f6fd39aa3520c4b4c7a1ca733ff07f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e6550b670c49798365a8db5f9b468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a680e6550b670c49798365a8db5f9b468">swap</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;r_ptr)</td></tr>
<tr class="memdesc:a680e6550b670c49798365a8db5f9b468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents with some other <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object.  <a href="#a680e6550b670c49798365a8db5f9b468">More...</a><br /></td></tr>
<tr class="separator:a680e6550b670c49798365a8db5f9b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Object/Pointer Access Functions</div></td></tr>
<tr class="memitem:a82d9b20546a02253188039c484bf7e1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b">is_null</a> () const </td></tr>
<tr class="memdesc:a82d9b20546a02253188039c484bf7e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the underlying pointer is null.  <a href="#a82d9b20546a02253188039c484bf7e1b">More...</a><br /></td></tr>
<tr class="separator:a82d9b20546a02253188039c484bf7e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093ff70ec999f2e08ae4bccdee6835de"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a093ff70ec999f2e08ae4bccdee6835de">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a093ff70ec999f2e08ae4bccdee6835de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer (<code>-&gt;</code>) access to members of underlying object.  <a href="#a093ff70ec999f2e08ae4bccdee6835de">More...</a><br /></td></tr>
<tr class="separator:a093ff70ec999f2e08ae4bccdee6835de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389d1ecca483ebc29e3804488414bb7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6389d1ecca483ebc29e3804488414bb7">operator*</a> () const </td></tr>
<tr class="memdesc:a6389d1ecca483ebc29e3804488414bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the underlying object.  <a href="#a6389d1ecca483ebc29e3804488414bb7">More...</a><br /></td></tr>
<tr class="separator:a6389d1ecca483ebc29e3804488414bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c70c3e4073cf89b9ec9d8a3ba15e7fc"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc">get</a> () const </td></tr>
<tr class="memdesc:a6c70c3e4073cf89b9ec9d8a3ba15e7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object.  <a href="#a6c70c3e4073cf89b9ec9d8a3ba15e7fc">More...</a><br /></td></tr>
<tr class="separator:a6c70c3e4073cf89b9ec9d8a3ba15e7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc80856037bd8908aafa11ea1f54082"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6dc80856037bd8908aafa11ea1f54082">getRawPtr</a> () const </td></tr>
<tr class="memdesc:a6dc80856037bd8908aafa11ea1f54082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object.  <a href="#a6dc80856037bd8908aafa11ea1f54082">More...</a><br /></td></tr>
<tr class="separator:a6dc80856037bd8908aafa11ea1f54082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c14fca0a5b1112dca76ac23a6813477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477">ptr</a> () const </td></tr>
<tr class="memdesc:a4c14fca0a5b1112dca76ac23a6813477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a safer wrapper raw C++ pointer to the underlying object.  <a href="#a4c14fca0a5b1112dca76ac23a6813477">More...</a><br /></td></tr>
<tr class="separator:a4c14fca0a5b1112dca76ac23a6813477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15be9a7c27995c887e068bdf409f572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#af15be9a7c27995c887e068bdf409f572">operator()</a> () const </td></tr>
<tr class="memdesc:af15be9a7c27995c887e068bdf409f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477" title="Get a safer wrapper raw C++ pointer to the underlying object. ">ptr()</a>.  <a href="#af15be9a7c27995c887e068bdf409f572">More...</a><br /></td></tr>
<tr class="separator:af15be9a7c27995c887e068bdf409f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6157f90659de0be48bfa9e25dec3acc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6157f90659de0be48bfa9e25dec3acc9">getConst</a> () const </td></tr>
<tr class="memdesc:a6157f90659de0be48bfa9e25dec3acc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an RCP&lt;const T&gt; version of *this.  <a href="#a6157f90659de0be48bfa9e25dec3acc9">More...</a><br /></td></tr>
<tr class="separator:a6157f90659de0be48bfa9e25dec3acc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reference counting</div></td></tr>
<tr class="memitem:a33e0971c45f2d3ffc11dd9a3d0a9306b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__teuchos__mem__mng__grp.html#ga24eff8f12d227acf5e40935b75541c49">ERCPStrength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a33e0971c45f2d3ffc11dd9a3d0a9306b">strength</a> () const </td></tr>
<tr class="memdesc:a33e0971c45f2d3ffc11dd9a3d0a9306b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strength of the pointer.  <a href="#a33e0971c45f2d3ffc11dd9a3d0a9306b">More...</a><br /></td></tr>
<tr class="separator:a33e0971c45f2d3ffc11dd9a3d0a9306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0a3fe89b6c69d57a18e8cc95e234cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afb0a3fe89b6c69d57a18e8cc95e234cc">is_valid_ptr</a> () const </td></tr>
<tr class="memdesc:afb0a3fe89b6c69d57a18e8cc95e234cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the underlying object pointer is still valid or not.  <a href="#afb0a3fe89b6c69d57a18e8cc95e234cc">More...</a><br /></td></tr>
<tr class="separator:afb0a3fe89b6c69d57a18e8cc95e234cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9577dd88522c03f42d6a2827b7dad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9">strong_count</a> () const </td></tr>
<tr class="memdesc:a7f9577dd88522c03f42d6a2827b7dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active <code>RCP&lt;&gt;</code> objects that have a "strong" reference to the underlying reference-counted object.  <a href="#a7f9577dd88522c03f42d6a2827b7dad9">More...</a><br /></td></tr>
<tr class="separator:a7f9577dd88522c03f42d6a2827b7dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b3c4a7ce399f9d4edf1e17ef96331a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a">weak_count</a> () const </td></tr>
<tr class="memdesc:a94b3c4a7ce399f9d4edf1e17ef96331a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active <code>RCP&lt;&gt;</code> objects that have a "weak" reference to the underlying reference-counted object.  <a href="#a94b3c4a7ce399f9d4edf1e17ef96331a">More...</a><br /></td></tr>
<tr class="separator:a94b3c4a7ce399f9d4edf1e17ef96331a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b195252f989cbcfbab991180fe8a24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a05b195252f989cbcfbab991180fe8a24">total_count</a> () const </td></tr>
<tr class="memdesc:a05b195252f989cbcfbab991180fe8a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total count (<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + <a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>).  <a href="#a05b195252f989cbcfbab991180fe8a24">More...</a><br /></td></tr>
<tr class="separator:a05b195252f989cbcfbab991180fe8a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c9e61ac5f074a375478598f08ba05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a2d8c9e61ac5f074a375478598f08ba05">set_has_ownership</a> ()</td></tr>
<tr class="memdesc:a2d8c9e61ac5f074a375478598f08ba05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give <code>this</code> and other <code>RCP&lt;&gt;</code> objects ownership of the referenced object <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code>.  <a href="#a2d8c9e61ac5f074a375478598f08ba05">More...</a><br /></td></tr>
<tr class="separator:a2d8c9e61ac5f074a375478598f08ba05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c524ad4c7f78e111cfc2411a1abf9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e">has_ownership</a> () const </td></tr>
<tr class="memdesc:a97c524ad4c7f78e111cfc2411a1abf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> has ownership of object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> in order to delete it.  <a href="#a97c524ad4c7f78e111cfc2411a1abf9e">More...</a><br /></td></tr>
<tr class="separator:a97c524ad4c7f78e111cfc2411a1abf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281058a75338ef844e6db99353bd6bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd">release</a> ()</td></tr>
<tr class="memdesc:a281058a75338ef844e6db99353bd6bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the ownership of the underlying dynamically allocated object.  <a href="#a281058a75338ef844e6db99353bd6bfd">More...</a><br /></td></tr>
<tr class="separator:a281058a75338ef844e6db99353bd6bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2fd6a9d63e9a9ca89ec45b15dcfdfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a9b2fd6a9d63e9a9ca89ec45b15dcfdfe">create_weak</a> () const </td></tr>
<tr class="memdesc:a9b2fd6a9d63e9a9ca89ec45b15dcfdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from another (strong) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object.  <a href="#a9b2fd6a9d63e9a9ca89ec45b15dcfdfe">More...</a><br /></td></tr>
<tr class="separator:a9b2fd6a9d63e9a9ca89ec45b15dcfdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5abe5380443c0a0496a4ec2466b4360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ac5abe5380443c0a0496a4ec2466b4360">create_strong</a> () const </td></tr>
<tr class="memdesc:ac5abe5380443c0a0496a4ec2466b4360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new strong <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from another (weak) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object.  <a href="#ac5abe5380443c0a0496a4ec2466b4360">More...</a><br /></td></tr>
<tr class="separator:ac5abe5380443c0a0496a4ec2466b4360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c01a6673adeba3353f7b3812e2aa88"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ab3c01a6673adeba3353f7b3812e2aa88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab3c01a6673adeba3353f7b3812e2aa88">shares_resource</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;r_ptr) const </td></tr>
<tr class="memdesc:ab3c01a6673adeba3353f7b3812e2aa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the smart pointers share the same underlying reference-counted object.  <a href="#ab3c01a6673adeba3353f7b3812e2aa88">More...</a><br /></td></tr>
<tr class="separator:ab3c01a6673adeba3353f7b3812e2aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assertions</div></td></tr>
<tr class="memitem:ae9309e8f2d1d75cba3f5097ff9ffb130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae9309e8f2d1d75cba3f5097ff9ffb130">assert_not_null</a> () const </td></tr>
<tr class="memdesc:ae9309e8f2d1d75cba3f5097ff9ffb130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code> if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a>==NULL</code>, otherwise returns reference to <code>*this</code>.  <a href="#ae9309e8f2d1d75cba3f5097ff9ffb130">More...</a><br /></td></tr>
<tr class="separator:ae9309e8f2d1d75cba3f5097ff9ffb130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbcd47cc5624f169c6543bf98ebd022"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aefbcd47cc5624f169c6543bf98ebd022">assert_valid_ptr</a> () const </td></tr>
<tr class="memdesc:aefbcd47cc5624f169c6543bf98ebd022"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the object pointer is non-null, assert that it is still valid.  <a href="#aefbcd47cc5624f169c6543bf98ebd022">More...</a><br /></td></tr>
<tr class="separator:aefbcd47cc5624f169c6543bf98ebd022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89abfd1a60e5e0e2d1092f694f220885"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a89abfd1a60e5e0e2d1092f694f220885">debug_assert_not_null</a> () const </td></tr>
<tr class="memdesc:a89abfd1a60e5e0e2d1092f694f220885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classTeuchos_1_1RCP.html#ae9309e8f2d1d75cba3f5097ff9ffb130" title="Throws NullReferenceError if this-&gt;get()==NULL, otherwise returns reference to *this. ">assert_not_null()</a></code> in a debug build.  <a href="#a89abfd1a60e5e0e2d1092f694f220885">More...</a><br /></td></tr>
<tr class="separator:a89abfd1a60e5e0e2d1092f694f220885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa32f49b803a4456c0d22e9c2ef6ba6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afaa32f49b803a4456c0d22e9c2ef6ba6">debug_assert_valid_ptr</a> () const </td></tr>
<tr class="memdesc:afaa32f49b803a4456c0d22e9c2ef6ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classTeuchos_1_1RCP.html#aefbcd47cc5624f169c6543bf98ebd022" title="If the object pointer is non-null, assert that it is still valid. ">assert_valid_ptr()</a></code> in a debug build.  <a href="#afaa32f49b803a4456c0d22e9c2ef6ba6">More...</a><br /></td></tr>
<tr class="separator:afaa32f49b803a4456c0d22e9c2ef6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">boost::shared_ptr compatiblity funtions.</div></td></tr>
<tr class="memitem:a2cb055f53bb8d7c624cdaa771e410dc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a2cb055f53bb8d7c624cdaa771e410dc1">reset</a> ()</td></tr>
<tr class="memdesc:a2cb055f53bb8d7c624cdaa771e410dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to null.  <a href="#a2cb055f53bb8d7c624cdaa771e410dc1">More...</a><br /></td></tr>
<tr class="separator:a2cb055f53bb8d7c624cdaa771e410dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a4649f01205b3e7c9906ccbb87628b"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a76a4649f01205b3e7c9906ccbb87628b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a76a4649f01205b3e7c9906ccbb87628b">reset</a> (T2 *p, bool <a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e">has_ownership</a>=true)</td></tr>
<tr class="memdesc:a76a4649f01205b3e7c9906ccbb87628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the raw pointer with default ownership to delete.  <a href="#a76a4649f01205b3e7c9906ccbb87628b">More...</a><br /></td></tr>
<tr class="separator:a76a4649f01205b3e7c9906ccbb87628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fec8776deaeb7099b47f595f5df7ef"><td class="memItemLeft" align="right" valign="top">TEUCHOS_DEPRECATED int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a80fec8776deaeb7099b47f595f5df7ef">count</a> () const </td></tr>
<tr class="memdesc:a80fec8776deaeb7099b47f595f5df7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a></code> [deprecated].  <a href="#a80fec8776deaeb7099b47f595f5df7ef">More...</a><br /></td></tr>
<tr class="separator:a80fec8776deaeb7099b47f595f5df7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6b52dbfe95890c138f922a4d4e475efd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b52dbfe95890c138f922a4d4e475efd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6b52dbfe95890c138f922a4d4e475efd">rcpFromPtr</a> (const <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477">ptr</a>)</td></tr>
<tr class="memdesc:a6b52dbfe95890c138f922a4d4e475efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an RCP&lt;T&gt; from a Ptr&lt;T&gt; object.  <a href="#a6b52dbfe95890c138f922a4d4e475efd">More...</a><br /></td></tr>
<tr class="separator:a6b52dbfe95890c138f922a4d4e475efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a> (const boost::shared_ptr&lt; T &gt; &amp;sptr)</td></tr>
<tr class="memdesc:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code>boost::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object.  <a href="#a7fd9e80180eec6cf6e3038505d3dc7a4">More...</a><br /></td></tr>
<tr class="separator:a7fd9e80180eec6cf6e3038505d3dc7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e779bd6873303e722f91b21ec558b93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e779bd6873303e722f91b21ec558b93"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6e779bd6873303e722f91b21ec558b93">shared_pointer</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;<a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>)</td></tr>
<tr class="memdesc:a6e779bd6873303e722f91b21ec558b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object and spits out a <code>boost::shared_ptr</code> object.  <a href="#a6e779bd6873303e722f91b21ec558b93">More...</a><br /></td></tr>
<tr class="separator:a6e779bd6873303e722f91b21ec558b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c212dad5228ed3adb1b7b376b37edc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a18c212dad5228ed3adb1b7b376b37edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a18c212dad5228ed3adb1b7b376b37edc">rcp</a> (T *p, bool owns_mem=true)</td></tr>
<tr class="memdesc:a18c212dad5228ed3adb1b7b376b37edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object properly typed.  <a href="#a18c212dad5228ed3adb1b7b376b37edc">More...</a><br /></td></tr>
<tr class="separator:a18c212dad5228ed3adb1b7b376b37edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6441ac96ec5797f7b487e4c851aebe"><td class="memTemplParams" colspan="2">template&lt;class T , class Dealloc_T &gt; </td></tr>
<tr class="memitem:a0c6441ac96ec5797f7b487e4c851aebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0c6441ac96ec5797f7b487e4c851aebe">rcpWithDealloc</a> (T *p, Dealloc_T dealloc, bool owns_mem=true)</td></tr>
<tr class="memdesc:a0c6441ac96ec5797f7b487e4c851aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a raw pointer with a deallocation policy.  <a href="#a0c6441ac96ec5797f7b487e4c851aebe">More...</a><br /></td></tr>
<tr class="separator:a0c6441ac96ec5797f7b487e4c851aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ff146d10e16f667ef0ce4523a5eef7"><td class="memTemplParams" colspan="2">template&lt;class T , class Dealloc_T &gt; </td></tr>
<tr class="memitem:a69ff146d10e16f667ef0ce4523a5eef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a69ff146d10e16f667ef0ce4523a5eef7">rcpWithDeallocUndef</a> (T *p, Dealloc_T dealloc, bool owns_mem=true)</td></tr>
<tr class="memdesc:a69ff146d10e16f667ef0ce4523a5eef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a raw pointer with a deallocation policy for an undefined type.  <a href="#a69ff146d10e16f667ef0ce4523a5eef7">More...</a><br /></td></tr>
<tr class="separator:a69ff146d10e16f667ef0ce4523a5eef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c754d72d6d232c97e38bc359ab6ef82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c754d72d6d232c97e38bc359ab6ef82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82">rcpFromRef</a> (T &amp;r)</td></tr>
<tr class="memdesc:a6c754d72d6d232c97e38bc359ab6ef82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from a raw object reference for a defined type.  <a href="#a6c754d72d6d232c97e38bc359ab6ef82">More...</a><br /></td></tr>
<tr class="separator:a6c754d72d6d232c97e38bc359ab6ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823eee3138de3b23dab97b3f37e197f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a823eee3138de3b23dab97b3f37e197f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3">rcpFromUndefRef</a> (T &amp;r)</td></tr>
<tr class="memdesc:a823eee3138de3b23dab97b3f37e197f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from a raw object reference for an undefined type.  <a href="#a823eee3138de3b23dab97b3f37e197f3">More...</a><br /></td></tr>
<tr class="separator:a823eee3138de3b23dab97b3f37e197f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02148aef172f7b2c0fb2de29cb01b91a"><td class="memTemplParams" colspan="2">template&lt;class T , class Embedded &gt; </td></tr>
<tr class="memitem:a02148aef172f7b2c0fb2de29cb01b91a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a">rcpWithEmbeddedObjPreDestroy</a> (T *p, const Embedded &amp;embedded, bool owns_mem=true)</td></tr>
<tr class="memdesc:a02148aef172f7b2c0fb2de29cb01b91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object.  <a href="#a02148aef172f7b2c0fb2de29cb01b91a">More...</a><br /></td></tr>
<tr class="separator:a02148aef172f7b2c0fb2de29cb01b91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memTemplParams" colspan="2">template&lt;class T , class Embedded &gt; </td></tr>
<tr class="memitem:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8272eea6a27f1fce6c30fc5d568f2de7">rcpWithEmbeddedObjPostDestroy</a> (T *p, const Embedded &amp;embedded, bool owns_mem=true)</td></tr>
<tr class="memdesc:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object.  <a href="#a8272eea6a27f1fce6c30fc5d568f2de7">More...</a><br /></td></tr>
<tr class="separator:a8272eea6a27f1fce6c30fc5d568f2de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506210a123b6e1747d910f037065bd73"><td class="memTemplParams" colspan="2">template&lt;class T , class Embedded &gt; </td></tr>
<tr class="memitem:a506210a123b6e1747d910f037065bd73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73">rcpWithEmbeddedObj</a> (T *p, const Embedded &amp;embedded, bool owns_mem=true)</td></tr>
<tr class="memdesc:a506210a123b6e1747d910f037065bd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object.  <a href="#a506210a123b6e1747d910f037065bd73">More...</a><br /></td></tr>
<tr class="separator:a506210a123b6e1747d910f037065bd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memTemplParams" colspan="2">template&lt;class T , class ParentT &gt; </td></tr>
<tr class="memitem:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#abaa6bdcd39bac7dd5c12c3e0f49eba25">rcpWithInvertedObjOwnership</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;child, const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; ParentT &gt; &amp;parent)</td></tr>
<tr class="memdesc:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> that inverts the ownership of parent and child.  <a href="#abaa6bdcd39bac7dd5c12c3e0f49eba25">More...</a><br /></td></tr>
<tr class="separator:abaa6bdcd39bac7dd5c12c3e0f49eba25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07a807743d25c57754a1988645ba791"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae07a807743d25c57754a1988645ba791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae07a807743d25c57754a1988645ba791">rcpCloneNode</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ae07a807743d25c57754a1988645ba791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object with a new <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> with memory pointing to the initial node.  <a href="#ae07a807743d25c57754a1988645ba791">More...</a><br /></td></tr>
<tr class="separator:ae07a807743d25c57754a1988645ba791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f5c533ebfe9dcb44310780b97a349f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10f5c533ebfe9dcb44310780b97a349f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a10f5c533ebfe9dcb44310780b97a349f">is_null</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a10f5c533ebfe9dcb44310780b97a349f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>.  <a href="#a10f5c533ebfe9dcb44310780b97a349f">More...</a><br /></td></tr>
<tr class="separator:a10f5c533ebfe9dcb44310780b97a349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad792756b35ab5a2fa8c1d1d608763aec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad792756b35ab5a2fa8c1d1d608763aec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ad792756b35ab5a2fa8c1d1d608763aec">nonnull</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ad792756b35ab5a2fa8c1d1d608763aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code>.  <a href="#ad792756b35ab5a2fa8c1d1d608763aec">More...</a><br /></td></tr>
<tr class="separator:ad792756b35ab5a2fa8c1d1d608763aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab9d7e0e5480ec8b455e38de0eee49e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afab9d7e0e5480ec8b455e38de0eee49e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afab9d7e0e5480ec8b455e38de0eee49e">operator==</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p, <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:afab9d7e0e5480ec8b455e38de0eee49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>.  <a href="#afab9d7e0e5480ec8b455e38de0eee49e">More...</a><br /></td></tr>
<tr class="separator:afab9d7e0e5480ec8b455e38de0eee49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4081b5c4ac5b9d630a695755a72771cc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4081b5c4ac5b9d630a695755a72771cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a4081b5c4ac5b9d630a695755a72771cc">operator!=</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p, <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>)</td></tr>
<tr class="memdesc:a4081b5c4ac5b9d630a695755a72771cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code>.  <a href="#a4081b5c4ac5b9d630a695755a72771cc">More...</a><br /></td></tr>
<tr class="separator:a4081b5c4ac5b9d630a695755a72771cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bddcdcdc506ddab9d82990bcb48f059"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a0bddcdcdc506ddab9d82990bcb48f059"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a0bddcdcdc506ddab9d82990bcb48f059">operator==</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1, const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p2)</td></tr>
<tr class="memdesc:a0bddcdcdc506ddab9d82990bcb48f059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> objects point to the same referenced-counted object and have the same node.  <a href="#a0bddcdcdc506ddab9d82990bcb48f059">More...</a><br /></td></tr>
<tr class="separator:a0bddcdcdc506ddab9d82990bcb48f059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58080d40b950da5009ceb8e33ce9d1c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ad58080d40b950da5009ceb8e33ce9d1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ad58080d40b950da5009ceb8e33ce9d1c">operator!=</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1, const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p2)</td></tr>
<tr class="memdesc:ad58080d40b950da5009ceb8e33ce9d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> objects do not point to the same referenced-counted object and have the same node.  <a href="#ad58080d40b950da5009ceb8e33ce9d1c">More...</a><br /></td></tr>
<tr class="separator:ad58080d40b950da5009ceb8e33ce9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fc9f719ee13e5d961dcf47053883b4"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a61fc9f719ee13e5d961dcf47053883b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a61fc9f719ee13e5d961dcf47053883b4">rcp_implicit_cast</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:a61fc9f719ee13e5d961dcf47053883b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a61fc9f719ee13e5d961dcf47053883b4">More...</a><br /></td></tr>
<tr class="separator:a61fc9f719ee13e5d961dcf47053883b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c369381869737e67be8cab843b18076"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a1c369381869737e67be8cab843b18076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1c369381869737e67be8cab843b18076">rcp_static_cast</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:a1c369381869737e67be8cab843b18076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a1c369381869737e67be8cab843b18076">More...</a><br /></td></tr>
<tr class="separator:a1c369381869737e67be8cab843b18076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a6931e6c2f74c9fa9467e5dc91c6cd983">rcp_const_cast</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a6931e6c2f74c9fa9467e5dc91c6cd983">More...</a><br /></td></tr>
<tr class="separator:a6931e6c2f74c9fa9467e5dc91c6cd983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1580c807c6df3fdbcb953687b4ff60c7"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a1580c807c6df3fdbcb953687b4ff60c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;p1, bool throw_on_fail=false)</td></tr>
<tr class="memdesc:a1580c807c6df3fdbcb953687b4ff60c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a1580c807c6df3fdbcb953687b4ff60c7">More...</a><br /></td></tr>
<tr class="separator:a1580c807c6df3fdbcb953687b4ff60c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd19618c28d1cbc6959f346cee07a7f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:addd19618c28d1cbc6959f346cee07a7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a> (const T1 &amp;extra_data, const std::string &amp;name, const <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &gt; &amp;p, <a class="el" href="group__teuchos__mem__mng__grp.html#gacd85ba81c085fde11a3ccc0dfb6f0c5e">EPrePostDestruction</a> destroy_when=POST_DESTROY, bool force_unique=true)</td></tr>
<tr class="memdesc:addd19618c28d1cbc6959f346cee07a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object.  <a href="#addd19618c28d1cbc6959f346cee07a7f">More...</a><br /></td></tr>
<tr class="separator:addd19618c28d1cbc6959f346cee07a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memTemplItemLeft" align="right" valign="top">const T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ab7f7cd634c8250ff0515bd55c5f3cde6">get_extra_data</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p, const std::string &amp;name)</td></tr>
<tr class="memdesc:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object.  <a href="#ab7f7cd634c8250ff0515bd55c5f3cde6">More...</a><br /></td></tr>
<tr class="separator:ab7f7cd634c8250ff0515bd55c5f3cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8978c29ca24e96cb61185507a0419dac"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a8978c29ca24e96cb61185507a0419dac"><td class="memTemplItemLeft" align="right" valign="top">T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a8978c29ca24e96cb61185507a0419dac">get_nonconst_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p, const std::string &amp;name)</td></tr>
<tr class="memdesc:a8978c29ca24e96cb61185507a0419dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object.  <a href="#a8978c29ca24e96cb61185507a0419dac">More...</a><br /></td></tr>
<tr class="separator:a8978c29ca24e96cb61185507a0419dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac70269754b423e8e76d2e75b3dfbf96"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aac70269754b423e8e76d2e75b3dfbf96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aac70269754b423e8e76d2e75b3dfbf96">get_optional_extra_data</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p, const std::string &amp;name)</td></tr>
<tr class="memdesc:aac70269754b423e8e76d2e75b3dfbf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object.  <a href="#aac70269754b423e8e76d2e75b3dfbf96">More...</a><br /></td></tr>
<tr class="separator:aac70269754b423e8e76d2e75b3dfbf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a7b838cf99afd0bb5f2ebc94ab8d73b59">get_optional_nonconst_extra_data</a> (<a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;p, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to non-const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object.  <a href="#a7b838cf99afd0bb5f2ebc94ab8d73b59">More...</a><br /></td></tr>
<tr class="separator:a7b838cf99afd0bb5f2ebc94ab8d73b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T , class T &gt; </td></tr>
<tr class="memitem:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memTemplItemLeft" align="right" valign="top">const Dealloc_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a62a1b34d2efe42b0a0fb4e20c1089f89">get_dealloc</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>const</code> reference to the underlying deallocator object.  <a href="#a62a1b34d2efe42b0a0fb4e20c1089f89">More...</a><br /></td></tr>
<tr class="separator:a62a1b34d2efe42b0a0fb4e20c1089f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T , class T &gt; </td></tr>
<tr class="memitem:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memTemplItemLeft" align="right" valign="top">Dealloc_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a67483a8eaf4d6a5f234e7bd6c971b009">get_nonconst_dealloc</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-<code>const</code> reference to the underlying deallocator object.  <a href="#a67483a8eaf4d6a5f234e7bd6c971b009">More...</a><br /></td></tr>
<tr class="separator:a67483a8eaf4d6a5f234e7bd6c971b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T , class T &gt; </td></tr>
<tr class="memitem:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const Dealloc_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ac7868e0bffe12f3a8c82daa61cd4cefb">get_optional_dealloc</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the underlying <code>const</code> deallocator object if it exists.  <a href="#ac7868e0bffe12f3a8c82daa61cd4cefb">More...</a><br /></td></tr>
<tr class="separator:ac7868e0bffe12f3a8c82daa61cd4cefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a73590cabeeb6ac3556981e068bd5d"><td class="memTemplParams" colspan="2">template&lt;class Dealloc_T , class T &gt; </td></tr>
<tr class="memitem:a40a73590cabeeb6ac3556981e068bd5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; Dealloc_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a40a73590cabeeb6ac3556981e068bd5d">get_optional_nonconst_dealloc</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a40a73590cabeeb6ac3556981e068bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the underlying non-<code>const</code> deallocator object if it exists.  <a href="#a40a73590cabeeb6ac3556981e068bd5d">More...</a><br /></td></tr>
<tr class="separator:a40a73590cabeeb6ac3556981e068bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9ce82fd86820b298f9c3847d585708"><td class="memTemplParams" colspan="2">template&lt;class TOrig , class Embedded , class T &gt; </td></tr>
<tr class="memitem:afd9ce82fd86820b298f9c3847d585708"><td class="memTemplItemLeft" align="right" valign="top">const Embedded &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708">getEmbeddedObj</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:afd9ce82fd86820b298f9c3847d585708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>.  <a href="#afd9ce82fd86820b298f9c3847d585708">More...</a><br /></td></tr>
<tr class="separator:afd9ce82fd86820b298f9c3847d585708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd3a9f656d730dea2902f08a765811"><td class="memTemplParams" colspan="2">template&lt;class TOrig , class Embedded , class T &gt; </td></tr>
<tr class="memitem:a5dfd3a9f656d730dea2902f08a765811"><td class="memTemplItemLeft" align="right" valign="top">Embedded &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a5dfd3a9f656d730dea2902f08a765811">getNonconstEmbeddedObj</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a5dfd3a9f656d730dea2902f08a765811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>.  <a href="#a5dfd3a9f656d730dea2902f08a765811">More...</a><br /></td></tr>
<tr class="separator:a5dfd3a9f656d730dea2902f08a765811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35995646037935daf4f98375cbb7ae3"><td class="memTemplParams" colspan="2">template&lt;class TOrig , class Embedded , class T &gt; </td></tr>
<tr class="memitem:ae35995646037935daf4f98375cbb7ae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const Embedded &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#ae35995646037935daf4f98375cbb7ae3">getOptionalEmbeddedObj</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ae35995646037935daf4f98375cbb7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a> to a const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>.  <a href="#ae35995646037935daf4f98375cbb7ae3">More...</a><br /></td></tr>
<tr class="separator:ae35995646037935daf4f98375cbb7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memTemplParams" colspan="2">template&lt;class TOrig , class Embedded , class T &gt; </td></tr>
<tr class="memitem:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; Embedded &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#a1fcb0b191b4d3f13cd7e2c139dcc4d8e">getOptionalNonconstEmbeddedObj</a> (const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a> to a non-const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>.  <a href="#a1fcb0b191b4d3f13cd7e2c139dcc4d8e">More...</a><br /></td></tr>
<tr class="separator:a1fcb0b191b4d3f13cd7e2c139dcc4d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTeuchos_1_1RCP.html#aa92c7a8fc60f4741319ee31a12a6d75b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream inserter.  <a href="#aa92c7a8fc60f4741319ee31a12a6d75b">More...</a><br /></td></tr>
<tr class="separator:aa92c7a8fc60f4741319ee31a12a6d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Teuchos::RCP&lt; T &gt;</h3>

<p>Smart reference counting pointer class for automatic garbage collection. </p>
<p>For a carefully written discussion about what this class is and basic details on how to use it see the <a href="../../../teuchos/doc/html/RefCountPtrBeginnersGuideSAND.pdf">beginners guide</a>.</p>
<p><b>Quickstart for <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code></b></p>
<p>Here we present a short, but fairly comprehensive, quick-start for the use of <code>RCP&lt;&gt;</code>. The use cases described here should cover the overwhelming majority of the use instances of <code>RCP&lt;&gt;</code> in a typical program.</p>
<p>The following class hierarchy will be used in the C++ examples given below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">public</span>: <span class="keyword">virtual</span> ~A(){} <span class="keyword">virtual</span> <span class="keywordtype">void</span> f(){} };</div><div class="line"><span class="keyword">class </span>B1 : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</div><div class="line"><span class="keyword">class </span>B2 : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</div><div class="line"><span class="keyword">class </span>C : <span class="keyword">virtual</span> <span class="keyword">public</span> B1, <span class="keyword">virtual</span> <span class="keyword">public</span> B2 {};</div><div class="line"></div><div class="line"><span class="keyword">class </span>D {};</div><div class="line"><span class="keyword">class </span>E : <span class="keyword">public</span> D {};</div></div><!-- fragment --><p>All of the following code examples used in this quickstart are assumed to be in the namespace <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos, as well as a number of utility routines. ">Teuchos</a></code> or have appropriate <code>using <a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos, as well as a number of utility routines. ">Teuchos</a>::...</code> declarations. This removes the need to explicitly use <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos, as well as a number of utility routines. ">Teuchos</a>::</code> to qualify classes, functions and other declarations from the <code><a class="el" href="namespaceTeuchos.html" title="The Teuchos namespace contains all of the classes, structs and enums used by Teuchos, as well as a number of utility routines. ">Teuchos</a></code> namespace. Note that some of the runtime checks are denoted as "debug runtime checked" which means that checking will only be performed in a debug build (that is one where the macro <code>TEUCHOS_DEBUG</code> is defined at compile time).</p>
<ol>
<li>
<p class="startli"><b>Creation of <code>RCP&lt;&gt;</code> objects</b></p>
<ol>
<li>
<p class="startli"><b>Creating an <code>RCP&lt;&gt;</code> object using <code>new</code></b></p>
<div class="fragment"><div class="line">RCP&lt;C&gt; c_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Creating a <code>RCP&lt;&gt;</code> object equipped with a specialized deallocator function</b> : <code><a class="el" href="classTeuchos_1_1DeallocFunctorDelete.html" title="Deallocator subclass that Allows any functor object (including a function pointer) to be used to free...">Teuchos::DeallocFunctorDelete</a></code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> someDeallocFunction(C* c_ptr);</div><div class="line"></div><div class="line">RCP&lt;C&gt; c_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> deallocFunctorDelete&lt;C&gt;(someDeallocFunction),<span class="keyword">true</span>);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Initializing a <code>RCP&lt;&gt;</code> object to NULL</b></p>
<div class="fragment"><div class="line">RCP&lt;C&gt; c_ptr;</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">RCP&lt;C&gt; c_ptr = null;</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Initializing a <code>RCP&lt;&gt;</code> object to an object {not} allocated with <code>new</code></b></p>
<div class="fragment"><div class="line">C c;</div><div class="line">RCP&lt;C&gt; c_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82">rcpFromRef</a>(c);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Copy constructor (implicit casting)</b></p>
<div class="fragment"><div class="line">RCP&lt;C&gt;       c_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C); <span class="comment">// No cast</span></div><div class="line">RCP&lt;A&gt;       a_ptr  = c_ptr;      <span class="comment">// Cast to base class</span></div><div class="line">RCP&lt;const A&gt; ca_ptr = a_ptr;      <span class="comment">// Cast from non-const to const</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Representing constantness and non-constantness</b></p>
<ol>
<li>
<p class="startli"><b>Non-constant pointer to non-constant object</b> </p><div class="fragment"><div class="line">RCP&lt;C&gt; c_ptr;</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Constant pointer to non-constant object</b> </p><div class="fragment"><div class="line"><span class="keyword">const</span> RCP&lt;C&gt; c_ptr;</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Non-Constant pointer to constant object</b> </p><div class="fragment"><div class="line">RCP&lt;const C&gt; c_ptr;</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Constant pointer to constant object</b> </p><div class="fragment"><div class="line"><span class="keyword">const</span> RCP&lt;const C&gt; c_ptr;</div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Reinitialization of <code>RCP&lt;&gt;</code> objects (using assignment operator)</b></p>
<ol>
<li>
<p class="startli"><b>Resetting from a raw pointer</b></p>
<div class="fragment"><div class="line">RCP&lt;A&gt; a_ptr;</div><div class="line">a_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Resetting to null</b></p>
<div class="fragment"><div class="line">RCP&lt;A&gt; a_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div><div class="line">a_ptr = null; <span class="comment">// The C object will be deleted here</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Assigning from a <code>RCP&lt;&gt;</code> object</b></p>
<div class="fragment"><div class="line">RCP&lt;A&gt; a_ptr1;</div><div class="line">RCP&lt;A&gt; a_ptr2 = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C());</div><div class="line">a_ptr1 = a_ptr2; <span class="comment">// Now a_ptr1 and a_ptr2 point to same C object</span></div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Accessing the reference-counted object</b></p>
<ol>
<li>
<p class="startli"><b>Access to object reference (debug runtime checked)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6389d1ecca483ebc29e3804488414bb7" title="Dereference the underlying object. ">Teuchos::RCP::operator*()</a></code></p>
<div class="fragment"><div class="line">C &amp;c_ref = *c_ptr;</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access to object pointer (unchecked, may return <code>NULL</code>)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">Teuchos::RCP::get()</a></code></p>
<div class="fragment"><div class="line">C *c_rptr = c_ptr.get();</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">C *c_rptr = c_ptr.getRawPtr();</div></div><!-- fragment --><p><b>WARNING:</b>: Avoid exposing raw C++ pointers!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access to object pointer (debug runtime checked, will not return <code>NULL</code>)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6389d1ecca483ebc29e3804488414bb7" title="Dereference the underlying object. ">Teuchos::RCP::operator*()</a></code></p>
<div class="fragment"><div class="line">C *c_rptr = &amp;*c_ptr;</div></div><!-- fragment --><p><b>WARNING:</b>: Avoid exposing raw C++ pointers!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access of object's member (debug runtime checked)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a093ff70ec999f2e08ae4bccdee6835de" title="Pointer (-&gt;) access to members of underlying object. ">Teuchos::RCP::operator-&gt;()</a></code></p>
<div class="fragment"><div class="line">c_ptr-&gt;f();</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Testing for non-null</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">Teuchos::RCP::get()</a></code>, <code>Teuchos::operator==()</code>, <code>Teuchos::operator!=()</code></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a_ptr.is_null) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is not null!\n&quot;</span>;</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a_ptr != null) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is not null!\n&quot;</span>;</div></div><!-- fragment --><p>or</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Testing for null</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!a_ptr.is_null()) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a_ptr == null) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b">is_null</a>(a_ptr)) std::cout &lt;&lt; <span class="stringliteral">&quot;a_ptr is null!\n&quot;</span>;</div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Casting</b></p>
<ol>
<li>
<p class="startli"><b>Implicit casting (see copy constructor above)</b></p>
<ol>
<li>
<p class="startli"><b>Using copy constructor (see above)</b></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Using conversion function</b></p>
<div class="fragment"><div class="line">RCP&lt;C&gt;       c_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);                       <span class="comment">// No cast</span></div><div class="line">RCP&lt;A&gt;       a_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a61fc9f719ee13e5d961dcf47053883b4">rcp_implicit_cast</a>&lt;A&gt;(c_ptr);      <span class="comment">// To base</span></div><div class="line">RCP&lt;const A&gt; ca_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a61fc9f719ee13e5d961dcf47053883b4">rcp_implicit_cast</a>&lt;<span class="keyword">const</span> A&gt;(a_ptr);<span class="comment">// To const</span></div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Casting away <code>const</code></b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a6931e6c2f74c9fa9467e5dc91c6cd983" title="Constant cast of underlying RCP type from T1* to T2*. ">rcp_const_cast()</a></code></p>
<div class="fragment"><div class="line">RCP&lt;const A&gt;  ca_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div><div class="line">RCP&lt;A&gt;        a_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a6931e6c2f74c9fa9467e5dc91c6cd983">rcp_const_cast</a>&lt;A&gt;(ca_ptr); <span class="comment">// cast away const!</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Static cast (no runtime check)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1c369381869737e67be8cab843b18076" title="Static cast of underlying RCP type from T1* to T2*. ">rcp_static_cast()</a></code></p>
<div class="fragment"><div class="line">RCP&lt;D&gt;     d_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> E);</div><div class="line">RCP&lt;E&gt;     e_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a1c369381869737e67be8cab843b18076">rcp_static_cast</a>&lt;E&gt;(d_ptr); <span class="comment">// Unchecked, unsafe?</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Dynamic cast (runtime checked, failed cast allowed)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7" title="Dynamic cast of underlying RCP type from T1* to T2*. ">rcp_dynamic_cast()</a></code></p>
<div class="fragment"><div class="line">RCP&lt;A&gt;     a_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div><div class="line">RCP&lt;B1&gt;    b1_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a>&lt;B1&gt;(a_ptr);  <span class="comment">// Checked, safe!</span></div><div class="line">RCP&lt;B2&gt;    b2_ptr = <a class="code" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a>&lt;B2&gt;(b1_ptr); <span class="comment">// Checked, safe!</span></div><div class="line">RCP&lt;C&gt;     c_ptr  = <a class="code" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a>&lt;C&gt;(b2_ptr);  <span class="comment">// Checked, safe!</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Dynamic cast (runtime checked, failed cast not allowed)</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7" title="Dynamic cast of underlying RCP type from T1* to T2*. ">rcp_dynamic_cast()</a></code></p>
<div class="fragment"><div class="line">RCP&lt;A&gt;     a_ptr1  = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div><div class="line">RCP&lt;A&gt;     a_ptr2  = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> A);</div><div class="line">RCP&lt;B1&gt;    b1_ptr1 = <a class="code" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a>&lt;B1&gt;(a_ptr1, <span class="keyword">true</span>);  <span class="comment">// Success!</span></div><div class="line">RCP&lt;B1&gt;    b1_ptr2 = <a class="code" href="classTeuchos_1_1RCP.html#a1580c807c6df3fdbcb953687b4ff60c7">rcp_dynamic_cast</a>&lt;B1&gt;(a_ptr2, <span class="keyword">true</span>);  <span class="comment">// Throw std::bad_cast!</span></div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Customized deallocators</b></p>
<ol>
<li>
<p class="startli"><b>Creating a <code>RCP&lt;&gt;</code> object with a custom deallocator</b> : <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object...">rcp()</a></code></p>
<p>TODO: Update this example!</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access customized deallocator (runtime checked, throws on failure)</b> : <code>Teuchos::get_dealloc()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MyCustomDealloc&lt;C&gt;</div><div class="line">  &amp;dealloc = get_dealloc&lt;MyCustomDealloc&lt;C&gt; &gt;(c_ptr);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Access optional customized deallocator</b> : <code>Teuchos::get_optional_dealloc()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Ptr&lt;const MyCustomDealloc&lt;C&gt; &gt; dealloc =</div><div class="line">  get_optional_dealloc&lt;MyCustomDealloc&lt;C&gt; &gt;(c_ptr);</div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b">is_null</a>(dealloc))</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This deallocator exits!\n&quot;</span>;</div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Managing extra data</b></p>
<ol>
<li>
<p class="startli"><b>Adding extra data (post destruction of extra data)</b> : <code>Teuchos::set_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a>(<a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> B1), <span class="stringliteral">&quot;A:B1&quot;</span>, inOutArg(a_ptr));</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Adding extra data (pre destruction of extra data)</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line"><a class="code" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f">set_extra_data</a>(<a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> B1),<span class="stringliteral">&quot;A:B1&quot;</span>, inOutArg(a_ptr), PRE_DESTORY);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Retrieving extra data</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line">get_extra_data&lt;RCP&lt;B1&gt; &gt;(a_ptr, <span class="stringliteral">&quot;A:B1&quot;</span>)-&gt;f();</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Resetting extra data</b> : <code>Teuchos::get_extra_data()</code></p>
<div class="fragment"><div class="line">get_extra_data&lt;RCP&lt;B1&gt; &gt;(a_ptr, <span class="stringliteral">&quot;A:B1&quot;</span>) = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(<span class="keyword">new</span> C);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Retrieving optional extra data</b> : <code>Teuchos::get_optional_extra_data()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Ptr&lt;const RCP&lt;B1&gt; &gt; b1 =</div><div class="line">  get_optional_extra_data&lt;RCP&lt;B1&gt; &gt;(a_ptr, <span class="stringliteral">&quot;A:B1&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b">is_null</a>(b1))</div><div class="line">  (*b1)-&gt;f();</div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p class="endli"></p>
</li>
</ol>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#_a14">ArrayRCP_test.cpp</a>, <a class="el" href="example_2RefCountPtr_2cxx_main_8cpp-example.html#_a0">example/RefCountPtr/cxx_main.cpp</a>, <a class="el" href="FancyOutputting_test_8cpp-example.html#_a7">FancyOutputting_test.cpp</a>, <a class="el" href="ParameterList_2cxx_main_8cpp-example.html#_a1">ParameterList/cxx_main.cpp</a>, <a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#_a0">test/MemoryManagement/RCP_test.cpp</a>, and <a class="el" href="TimeMonitor_2cxx_main_8cpp-example.html#_a0">TimeMonitor/cxx_main.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Teuchos__ParameterListAcceptor_8hpp_source.html#l00051">51</a> of file <a class="el" href="Teuchos__ParameterListAcceptor_8hpp_source.html">Teuchos_ParameterListAcceptor.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5718fa8c455b445078632723c8666480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html#a5718fa8c455b445078632723c8666480">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p>Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00433">433</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6df5f0ec485e775f8d35bfdd2dbb0eac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname"><em>null_arg</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize <code>RCP&lt;T&gt;</code> to NULL. </p>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a33e0971c45f2d3ffc11dd9a3d0a9306b" title="Strength of the pointer. ">strength()</a> == RCP_STRENGTH_INVALID</code> </li>
<li>
<code>this-&gt;is_vali_ptr() == true</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == false</code> </li>
</ul>
<p>This allows clients to write code like: </p><div class="fragment"><div class="line">RCP&lt;int&gt; p = null;</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">RCP&lt;int&gt; p;</div></div><!-- fragment --><p> and construct to <code>NULL</code> </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00149">149</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca5aaa0a0ee98f43a178e28ca5ade6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer. </p>
<p>Note that this constructor is declared explicit so there is no implicit conversion from a raw pointer to an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> allowed. If <code>has_ownership==false</code>, then no attempt to delete the object will occur.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == p</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a33e0971c45f2d3ffc11dd9a3d0a9306b" title="Strength of the pointer. ">strength()</a> == RCP_STRONG</code> </li>
<li>
<code>this-&gt;is_vali_ptr() == true</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == has_ownership</code> </li>
</ul>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object...">rcp()</a></code> function. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00192">192</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7153f6d53b495afd4c1a4a45d9710d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Dealloc_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dealloc_T&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_ownership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer and a custom deallocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Pointer to the reference-counted object to be wrapped</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object that will be copied by value and will perform the custom deallocation of the object pointed to by <code>p</code> when the last <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object goes away. See the class <code><a class="el" href="classTeuchos_1_1DeallocDelete.html" title="Policy class for deallocator that uses delete to delete a pointer which is used by RCP...">DeallocDelete</a></code> for the specfication and behavior of this policy interface.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == p</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a33e0971c45f2d3ffc11dd9a3d0a9306b" title="Strength of the pointer. ">strength()</a> == RCP_STRONG</code> </li>
<li>
<code>this-&gt;is_vali_ptr() == true</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a> == 0</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == has_ownership</code> </li>
<li>
<code>get_dealloc&lt;Delalloc_T&gt;(*this)</code> returns a copy of the custom deallocator object <code>dealloc&gt;/tt&gt;. </code></li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00226">226</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8711f68aa09dcaf4756aa19949d2d44a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from another <code>RCP&lt;T&gt;</code> object. </p>
<p>After construction, <code>this</code> and <code>r_ptr</code> will reference the same object.</p>
<p>This form of the copy constructor is required even though the below more general templated version is sufficient since some compilers will generate this function automatically which will give an incorrect implementation.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00279">279</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c3e448a0ec56fe6176508c43e51c66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from another <code>RCP&lt;T2&gt;</code> object (implicit conversion only). </p>
<p>This function allows the implicit conversion of smart pointer objects just like with raw C++ pointers. Note that this function will only compile if the statement <code>T1 *ptr = r_ptr.get()</code> will compile.</p>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00287">287</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32c1a9a58e67a6d0a3fbdbb86bf8701b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::~<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a reference to a dynamically allocated object and possibly deletes the object if owned. </p>
<p>Deletes the object if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code>. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> but <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == false</code> then the object is not deleted. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> &gt; 1</code> then the internal reference count shared by all the other related <code><a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac" title="Initialize RCP&lt;T&gt; to NULL. ">RCP&lt;...&gt;</a></code> objects for this shared object is deincremented by one. If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code> then nothing happens. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00295">295</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa3e9fabd5a8558882ea4a14dde9f82df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPWeakNoDealloc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> from a raw pointer to a type that <em>is</em> defined. </p>
<p>This version avoids adding a deallocator but still requires the type to be defined since it looks up the base object's address when doing <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> tracing.</p>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a6c754d72d6d232c97e38bc359ab6ef82" title="Return a non-owning weak RCP object from a raw object reference for a defined type. ">rcpFromRef()</a></code> function. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00156">156</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16286f0170a5ae6c7c2327ab12c681cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPUndefinedWeakNoDealloc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a non-owning <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> from a raw pointer to a type that is <em>not</em> defined. </p>
<p>This version avoids any type of compile-time queries of the type that would fail due to the type being undefined.</p>
<p>NOTE: It is recommended that this constructor never be called directly but only through a type-specific non-member constructor function or at least through the general non-member <code><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3" title="Return a non-owning weak RCP object from a raw object reference for an undefined type. ">rcpFromUndefRef()</a></code> function. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00184">184</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9388b91f32514229024f6a108d64529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Dealloc_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::<a class="el" href="classTeuchos_1_1RCP.html">RCP</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dealloc_T&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERCPUndefinedWithDealloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a raw pointer and a custom deallocator for an undefined type. </p>
<p>This version avoids any type of compile-time queries of the type that would fail due to the type being undefined. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00252">252</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aed3bf10956b92aeebe3bf42a37d7d05f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the pointer to the referenced object and increment the reference count. </p>
<p>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> before this operation is called, then the object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> will be deleted (usually using <code>delete</code>) prior to binding to the pointer (possibly <code>NULL</code>) pointed to in <code>r_ptr</code>. Assignment to self (i.e. <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == r_ptr.get()</code>) is harmless and this function does nothing.</p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == r_ptr.get()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == r_ptr.strong_count()</code> </li>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == r_ptr.has_ownership()</code> </li>
<li>
If <code>r_ptr.get() != NULL</code> then <code>r_ptr.strong_count()</code> is incremented by 1 </li>
</ul>
<p>Provides the "strong guarantee" in a debug build! </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00301">301</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f6fd39aa3520c4b4c7a1ca733ff07f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to null. </p>
<p>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == true</code> and <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> == 1</code> before this operation is called, then the object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> will be deleted (usually using <code>delete</code>) prior to binding to the pointer (possibly <code>NULL</code>) pointed to in <code>r_ptr</code>.</p>
<p><b>Postconditons:</b></p><ul>
<li>
See <code><a class="el" href="classTeuchos_1_1RCP.html#a6df5f0ec485e775f8d35bfdd2dbb0eac" title="Initialize RCP&lt;T&gt; to NULL. ">RCP(ENull)</a></code> </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00315">315</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a680e6550b670c49798365a8db5f9b468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents with some other <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00324">324</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82d9b20546a02253188039c484bf7e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the underlying pointer is null. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00336">336</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a093ff70ec999f2e08ae4bccdee6835de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer (<code>-&gt;</code>) access to members of underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00344">344</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6389d1ecca483ebc29e3804488414bb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00354">354</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c70c3e4073cf89b9ec9d8a3ba15e7fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw C++ pointer to the underlying object. </p>
<p>NOTE: Prefer to get the safer Ptr&lt;T&gt; object from <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477" title="Get a safer wrapper raw C++ pointer to the underlying object. ">ptr()</a></code>! </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00363">363</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6dc80856037bd8908aafa11ea1f54082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::getRawPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw C++ pointer to the underlying object. </p>
<p>NOTE: Prefer to get the safer Ptr&lt;T&gt; object from <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477" title="Get a safer wrapper raw C++ pointer to the underlying object. ">ptr()</a></code>! </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00372">372</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c14fca0a5b1112dca76ac23a6813477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a safer wrapper raw C++ pointer to the underlying object. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00380">380</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af15be9a7c27995c887e068bdf409f572"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shorthand for <a class="el" href="classTeuchos_1_1RCP.html#a4c14fca0a5b1112dca76ac23a6813477" title="Get a safer wrapper raw C++ pointer to the underlying object. ">ptr()</a>. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00392">392</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6157f90659de0be48bfa9e25dec3acc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; const T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::getConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an RCP&lt;const T&gt; version of *this. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00400">400</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33e0971c45f2d3ffc11dd9a3d0a9306b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__teuchos__mem__mng__grp.html#ga24eff8f12d227acf5e40935b75541c49">ERCPStrength</a> <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::strength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strength of the pointer. </p>
<p>Return values:</p><ul>
<li>
<code>RCP_STRONG</code>: Underlying reference-counted object will be deleted when <code>*this</code> is destroyed if <code><a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a>==1</code>. </li>
<li>
<code>RCP_WEAK</code>: Underlying reference-counted object will not be deleted when <code>*this</code> is destroyed if <code><a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> &gt; 0</code>. </li>
<li>
<code>RCP_STRENGTH_INVALID</code>: <code>*this</code> is not strong or weak but is null. </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00411">411</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb0a3fe89b6c69d57a18e8cc95e234cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::is_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the underlying object pointer is still valid or not. </p>
<p>The underlying object will not be valid if the strong count has gone to zero but the weak count thas not.</p>
<p>NOTE: Null is a valid object pointer. If you want to know if there is a non-null object and it is valid then <code>!is_null() &amp;&amp; <a class="el" href="classTeuchos_1_1RCP.html#afb0a3fe89b6c69d57a18e8cc95e234cc" title="Return if the underlying object pointer is still valid or not. ">is_valid_ptr()</a></code> will be <code>true</code>. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00419">419</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9577dd88522c03f42d6a2827b7dad9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::strong_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active <code>RCP&lt;&gt;</code> objects that have a "strong" reference to the underlying reference-counted object. </p>
<dl class="section return"><dt>Returns</dt><dd>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code> then this function returns 0. </dd></dl>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00429">429</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94b3c4a7ce399f9d4edf1e17ef96331a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::weak_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active <code>RCP&lt;&gt;</code> objects that have a "weak" reference to the underlying reference-counted object. </p>
<dl class="section return"><dt>Returns</dt><dd>If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code> then this function returns 0. </dd></dl>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00437">437</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05b195252f989cbcfbab991180fe8a24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::total_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total count (<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + <a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>). </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00445">445</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8c9e61ac5f074a375478598f08ba05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::set_has_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give <code>this</code> and other <code>RCP&lt;&gt;</code> objects ownership of the referenced object <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code>. </p>
<p>See <a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned...">~RCP()</a> above. This function does nothing if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code>.</p>
<p><b>Postconditions:</b> </p><ul>
<li>
If <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code> then <ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == false</code> (always!). </li>
</ul>
</li>
<li>
else <ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == true</code> </li>
</ul>
</li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00453">453</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97c524ad4c7f78e111cfc2411a1abf9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::has_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> has ownership of object pointed to by <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> in order to delete it. </p>
<p>See <a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned...">~RCP()</a> above.</p>
<dl class="section return"><dt>Returns</dt><dd>If this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> <code>== NULL</code> then this function always returns <code>false</code>. Otherwise the value returned from this function depends on which function was called most recently, if any; <a class="el" href="classTeuchos_1_1RCP.html#a2d8c9e61ac5f074a375478598f08ba05" title="Give this and other RCP&lt;&gt; objects ownership of the referenced object this-&gt;get(). ...">set_has_ownership()</a> (<code>true</code>) or <a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd" title="Release the ownership of the underlying dynamically allocated object. ">release()</a> (<code>false</code>). </dd></dl>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00461">461</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a281058a75338ef844e6db99353bd6bfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the ownership of the underlying dynamically allocated object. </p>
<p><b>WARNING!</b> Never call <code>delete rcp.release().<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> as this can cause all kinds of segfaults. Instead, release your use of the shared object by simply assigning the <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object to <code>Teuchos::null</code>.</p>
<p>This function should only be used as last result when all hell has broken loose and memory management control has broken down. This function is not to be used lightly!</p>
<p>After this function is called then the client is responsible for deallocating the shared object no matter how many <code>ref_count_prt&lt;T&gt;</code> objects have a reference to it. If <code>this-&gt;</code><a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a><code>== NULL</code>, then this call is meaningless.</p>
<p>Note that this function does not have the exact same semantics as does <code>auto_ptr&lt;T&gt;::release()</code>. In <code>auto_ptr&lt;T&gt;::release()</code>, <code>this</code> is set to <code>NULL</code> while here in RCP&lt;T&gt;:: <a class="el" href="classTeuchos_1_1RCP.html#a281058a75338ef844e6db99353bd6bfd" title="Release the ownership of the underlying dynamically allocated object. ">release()</a> only an ownership flag is set and <code>*this</code> still points to the same object. It would be difficult to duplicate the behavior of <code>auto_ptr&lt;T&gt;::release()</code> for this class.</p>
<p><b>Postconditions:</b> </p><ul>
<li>
<code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a> == false</code> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> </dd></dl>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00469">469</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b2fd6a9d63e9a9ca89ec45b15dcfdfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::create_weak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from another (strong) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object. </p>
<p>ToDo: Explain this!</p>
<p><b>Preconditons:</b> </p><ul>
<li>
<code>returnVal.is_valid_ptr()==true</code> </li>
</ul>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>returnVal.get() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> </li>
<li>
<code>returnVal.strong_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a></code> </li>
<li>
<code>returnVal.weak_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a>+1</code> </li>
<li>
<code>returnVal.strength() == RCP_WEAK</code> </li>
<li>
<code>returnVal.has_ownership() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a></code> </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00479">479</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5abe5380443c0a0496a4ec2466b4360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::create_strong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new strong <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from another (weak) <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object. </p>
<p>ToDo: Explain this!</p>
<p><b>Preconditons:</b> </p><ul>
<li>
<code>returnVal.is_valid_ptr()==true</code> </li>
</ul>
<p><b>Postconditons:</b> </p><ul>
<li>
<code>returnVal.get() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a></code> </li>
<li>
<code>returnVal.strong_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a> + 1</code> </li>
<li>
<code>returnVal.weak_count() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a94b3c4a7ce399f9d4edf1e17ef96331a" title="Return the number of active RCP&lt;&gt; objects that have a &quot;weak&quot; reference to the underlying reference-co...">weak_count()</a></code> </li>
<li>
<code>returnVal.strength() == RCP_STRONG</code> </li>
<li>
<code>returnVal.has_ownership() == this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a97c524ad4c7f78e111cfc2411a1abf9e" title="Returns true if this has ownership of object pointed to by this-&gt;get() in order to delete it...">has_ownership()</a></code> </li>
</ul>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00488">488</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3c01a6673adeba3353f7b3812e2aa88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::shares_resource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the smart pointers share the same underlying reference-counted object. </p>
<p>This method does more than just check if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> == r_ptr.get()</code>. It also checks to see if the underlying reference counting machinary is the same. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00498">498</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9309e8f2d1d75cba3f5097ff9ffb130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::assert_not_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code> if <code>this-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a>==NULL</code>, otherwise returns reference to <code>*this</code>. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00512">512</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aefbcd47cc5624f169c6543bf98ebd022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::assert_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the object pointer is non-null, assert that it is still valid. </p>
<p>If <code><a class="el" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b" title="Returns true if the underlying pointer is null. ">is_null()</a>==false &amp;&amp; <a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a>==0</code>, this will throw <code>DanglingReferenceErorr</code> with a great error message.</p>
<p>If <code><a class="el" href="classTeuchos_1_1RCP.html#a82d9b20546a02253188039c484bf7e1b" title="Returns true if the underlying pointer is null. ">is_null()</a>==true</code>, then this will not throw any exception.</p>
<p>In this context, null is a valid object. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00522">522</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89abfd1a60e5e0e2d1092f694f220885"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt;T&gt;&amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::debug_assert_not_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classTeuchos_1_1RCP.html#ae9309e8f2d1d75cba3f5097ff9ffb130" title="Throws NullReferenceError if this-&gt;get()==NULL, otherwise returns reference to *this. ">assert_not_null()</a></code> in a debug build. </p>

<p>Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00817">817</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afaa32f49b803a4456c0d22e9c2ef6ba6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt;T&gt;&amp; <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::debug_assert_valid_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classTeuchos_1_1RCP.html#aefbcd47cc5624f169c6543bf98ebd022" title="If the object pointer is non-null, assert that it is still valid. ">assert_valid_ptr()</a></code> in a debug build. </p>

<p>Definition at line <a class="el" href="Teuchos__RCPDecl_8hpp_source.html#l00826">826</a> of file <a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cb055f53bb8d7c624cdaa771e410dc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to null. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00535">535</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76a4649f01205b3e7c9906ccbb87628b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_ownership</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the raw pointer with default ownership to delete. </p>
<p>Equivalent to calling:</p>
<div class="fragment"><div class="line">r_rcp = <a class="code" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4">rcp</a>(p)</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00549">549</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80fec8776deaeb7099b47f595f5df7ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTeuchos_1_1RCP.html">Teuchos::RCP</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="classTeuchos_1_1RCP.html#a7f9577dd88522c03f42d6a2827b7dad9" title="Return the number of active RCP&lt;&gt; objects that have a &quot;strong&quot; reference to the underlying reference-...">strong_count()</a></code> [deprecated]. </p>

<p>Definition at line <a class="el" href="Teuchos__RCP_8hpp_source.html#l00557">557</a> of file <a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae62facd370a837a6e56086869977621b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to initialize a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object to NULL using an implicit conversion! </p>

<p>Definition at line <a class="el" href="Teuchos__ENull_8hpp_source.html#l00054">54</a> of file <a class="el" href="Teuchos__ENull_8hpp_source.html">Teuchos_ENull.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b52dbfe95890c138f922a4d4e475efd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpFromPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an RCP&lt;T&gt; from a Ptr&lt;T&gt; object. </p>

<p>Definition at line <a class="el" href="Teuchos__PtrDecl_8hpp_source.html#l00306">306</a> of file <a class="el" href="Teuchos__PtrDecl_8hpp_source.html">Teuchos_PtrDecl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7fd9e80180eec6cf6e3038505d3dc7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcp </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code>boost::shared_ptr</code> object and spits out a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object. </p>
<p>If the input <code>boost::shared_ptr</code> already wraps a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object, then that <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ArrayRCP_test_8cpp-example.html#a19">ArrayRCP_test.cpp</a>, and <a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a9">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6e779bd6873303e722f91b21ec558b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; T &gt; shared_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function that takes in a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> object and spits out a <code>boost::shared_ptr</code> object. </p>
<p>If the input <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">Teuchos::RCP</a></code> already wraps a <code>boost::shared_ptr</code> object, then that <code>boost::shared_ptr</code> object will be copied and returned.</p>
<p>This function is not complicated, just look at its defintion below. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a28">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a18c212dad5228ed3adb1b7b376b37edc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcp </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object properly typed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Pointer to an object to be reference counted.</td></tr>
    <tr><td class="paramname">owns_mem</td><td>[in] If <code>owns_mem==true</code> then <code>delete p</code> will be called when the last reference to this object is removed. If <code>owns_mem==false</code> then nothing will happen to delete the the object pointed to by <code>p</code> when the last reference is removed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Preconditions:</b></p><ul>
<li>
If <code>owns_mem==true</code> then <code>p</code> must have been created by calling <code>new</code> to create the object since <code>delete p</code> will be called eventually. </li>
</ul>
<p>If the pointer <code>p</code> did not come from <code>new</code> then either the client should use the version of <code><a class="el" href="classTeuchos_1_1RCP.html#a7fd9e80180eec6cf6e3038505d3dc7a4" title="Conversion function that takes in a boost::shared_ptr object and spits out a Teuchos::RCP object...">rcp()</a></code> that that uses a deallocator policy object or should pass in <code>owns_mem = false</code>. </p>

</div>
</div>
<a class="anchor" id="a0c6441ac96ec5797f7b487e4c851aebe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Dealloc_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithDealloc </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dealloc_T&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a raw pointer with a deallocation policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] <a class="el" href="namespaceRaw.html" title="&quot;Raw&quot; input of sparse matrices from Matrix Market files. ">Raw</a> C++ pointer that <code>this</code> will represent.</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object (copied by value) that defines a function <code>void Dealloc_T::free(T* p)</code> that will free the underlying object.</td></tr>
    <tr><td class="paramname">owns_mem</td><td>[in] If true then <code>return</code> is allowed to delete the underlying pointer by calling <code>dealloc.free(p)</code>. when all references have been removed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Preconditions:</b></p><ul>
<li>
The function <code>void Dealloc_T::free(T* p)</code> exists. </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
<code>return.get() == p</code> </li>
<li>
If <code>p == NULL</code> then <ul>
<li>
<code>return.count() == 0</code> </li>
<li>
<code>return.has_ownership() == false</code> </li>
</ul>
</li>
<li>
else <ul>
<li>
<code>return.count() == 1</code> </li>
<li>
<code>return.has_ownership() == owns_mem</code> </li>
</ul>
</li>
</ul>
<p>By default, <code>return</code> has ownership to delete the object pointed to by <code>p</code> when <code>return</code> is deleted (see <code><a class="el" href="classTeuchos_1_1RCP.html#a32c1a9a58e67a6d0a3fbdbb86bf8701b" title="Removes a reference to a dynamically allocated object and possibly deletes the object if owned...">~RCP()</a>)</code>. If <code>owns_mem==true</code>, it is vital that the address <code>p</code> passed in is the same address that was returned by <code>new</code>. With multiple inheritance this is not always the case. See the above discussion. This class is templated to accept a deallocator object that will free the pointer. The other functions use a default deallocator of type <code><a class="el" href="classTeuchos_1_1DeallocDelete.html" title="Policy class for deallocator that uses delete to delete a pointer which is used by RCP...">DeallocDelete</a></code> which has a method <code><a class="el" href="classTeuchos_1_1DeallocDelete.html#aa4b0787f97b55448e767d77f8f3e2b04" title="Deallocates a pointer ptr using delete ptr (required). ">DeallocDelete::free()</a></code> which just calls <code>delete p</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a15">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a69ff146d10e16f667ef0ce4523a5eef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Dealloc_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithDeallocUndef </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dealloc_T&#160;</td>
          <td class="paramname"><em>dealloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a raw pointer with a deallocation policy for an undefined type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] <a class="el" href="namespaceRaw.html" title="&quot;Raw&quot; input of sparse matrices from Matrix Market files. ">Raw</a> C++ pointer that <code>this</code> will represent.</td></tr>
    <tr><td class="paramname">dealloc</td><td>[in] Deallocator policy object (copied by value) that defines a function <code>void Dealloc_T::free(T* p)</code> that will free the underlying object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a27">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6c754d72d6d232c97e38bc359ab6ef82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpFromRef </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from a raw object reference for a defined type. </p>
<p>NOTE: When debug mode is turned on, in general, the type must be defined. If the type is undefined, then the function <code><a class="el" href="classTeuchos_1_1RCP.html#a823eee3138de3b23dab97b3f37e197f3" title="Return a non-owning weak RCP object from a raw object reference for an undefined type. ">rcpFromUndefRef()</a></code> should be called instead. </p>

</div>
</div>
<a class="anchor" id="a823eee3138de3b23dab97b3f37e197f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpFromUndefRef </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-owning weak <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object from a raw object reference for an undefined type. </p>
<p>NOTE: This version will not be able to use <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> tracing to create a weak reference to an existing <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a>. Therefore, you should only use this version with an undefined type. </p>

</div>
</div>
<a class="anchor" id="a02148aef172f7b2c0fb2de29cb01b91a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Embedded &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithEmbeddedObjPreDestroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Embedded &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object. </p>
<p>In this case the embedded object is destroyed (by setting to Embedded()) before the object at <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(), rcpWithEmbeddedObjPostDestory(), or rcpWithEmbeddedObj(). ">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a24">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8272eea6a27f1fce6c30fc5d568f2de7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Embedded &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithEmbeddedObjPostDestroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Embedded &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object. </p>
<p>In this case the embedded object is destroyed (by setting to Embedded()) after the object at <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(), rcpWithEmbeddedObjPostDestory(), or rcpWithEmbeddedObj(). ">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a25">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a506210a123b6e1747d910f037065bd73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Embedded &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Embedded &amp;&#160;</td>
          <td class="paramname"><em>embedded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_mem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> with and also put in an embedded object. </p>
<p>This function should be called when it is not important when the embedded object is destroyed (by setting to Embedded()) with respect to when <code>*p</code> is destroyed.</p>
<p>The embedded object can be extracted using <code><a class="el" href="classTeuchos_1_1RCP.html#afd9ce82fd86820b298f9c3847d585708" title="Get a const reference to an embedded object that was set by calling rcpWithEmbeddedObjPreDestroy(), rcpWithEmbeddedObjPostDestory(), or rcpWithEmbeddedObj(). ">getEmbeddedObj()</a></code> and <code>getNonconstEmbeddedObject()</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a23">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abaa6bdcd39bac7dd5c12c3e0f49eba25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ParentT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpWithInvertedObjOwnership </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; ParentT &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> that inverts the ownership of parent and child. </p>
<p>This implements the "inverted object ownership" idiom.</p>
<p>NOTE: The parent can be retrieved using the function <code>getInvertedObjOwnershipParent(...)</code>. </p>

</div>
</div>
<a class="anchor" id="ae07a807743d25c57754a1988645ba791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; rcpCloneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object with a new <a class="el" href="classTeuchos_1_1RCPNode.html" title="Node class to keep track of address and the reference count for a reference-counted utility class and...">RCPNode</a> with memory pointing to the initial node. </p>
<p>The purpose of this function is to create a new "handle" to the underlying memory with its own seprate reference count. The new <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object will have a new <a class="el" href="classTeuchos_1_1RCPNodeTmpl.html" title="Templated implementation class of RCPNode that has the responsibility for deleting the reference-coun...">RCPNodeTmpl</a> object that has a copy of the input <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> object embedded in it. This maintains the correct reference counting behaviors but now gives a private count. One would want to use rcpCloneNode(...) whenever it is important to keep a private reference count which is needed for some types of use cases. </p>

</div>
</div>
<a class="anchor" id="a10f5c533ebfe9dcb44310780b97a349f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()==NULL</code>. </p>

</div>
</div>
<a class="anchor" id="ad792756b35ab5a2fa8c1d1d608763aec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nonnull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()!=NULL</code>. </p>

</div>
</div>
<a class="anchor" id="afab9d7e0e5480ec8b455e38de0eee49e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()==NULL</code>. </p>

</div>
</div>
<a class="anchor" id="a4081b5c4ac5b9d630a695755a72771cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html#ae62facd370a837a6e56086869977621b">ENull</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>p.get()!=NULL</code>. </p>

</div>
</div>
<a class="anchor" id="a0bddcdcdc506ddab9d82990bcb48f059"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> objects point to the same referenced-counted object and have the same node. </p>

</div>
</div>
<a class="anchor" id="ad58080d40b950da5009ceb8e33ce9d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> objects do not point to the same referenced-counted object and have the same node. </p>

</div>
</div>
<a class="anchor" id="a61fc9f719ee13e5d961dcf47053883b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; rcp_implicit_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>T2* p2 = p1.get();</code>) compiles.</p>
<p>This is to be used for conversions up an inheritance hierarchy and from non-const to const and any other standard implicit pointer conversions allowed by C++. </p>

</div>
</div>
<a class="anchor" id="a1c369381869737e67be8cab843b18076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; rcp_static_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>static_cast&lt;T2*&gt;(p1.get());</code>) compiles.</p>
<p>This can safely be used for conversion down an inheritance hierarchy with polymorphic types only if <code>dynamic_cast&lt;T2&gt;(p1.get()) == static_cast&lt;T2&gt;(p1.get())</code>. If not then you have to use <code>rcp_dynamic_cast<code>&lt;T2&gt;(p1)</code>. </code></p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a14">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6931e6c2f74c9fa9467e5dc91c6cd983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; rcp_const_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>This function will compile only if (<code>const_cast&lt;T2*&gt;(p1.get());</code>) compiles. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a12">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1580c807c6df3fdbcb953687b4ff60c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; rcp_dynamic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throw_on_fail</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast of underlying <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>[in] The smart pointer casting from</td></tr>
    <tr><td class="paramname">throw_on_fail</td><td>[in] If <code>true</code> then if the cast fails (for <code>p1.get()!=NULL) then a <code>std::bad_cast</code> std::exception is thrown with a very informative error message.</code></td></tr>
  </table>
  </dd>
</dl>
<p><b>Postconditions:</b></p><ul>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==true &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then an <code>std::bad_cast</code> std::exception is thrown with a very informative error message. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())!=NULL ) == true</code> then <code>return.get() == dynamic_cast&lt;T2*&gt;(p1.get())</code>. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==false &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
<li>
<code> If <code>( p1.get()==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
</ul>
<p><code>This function will compile only if (<code>dynamic_cast&lt;T2*&gt;(p1.get());</code>) compiles. </code></p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a13">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="addd19618c28d1cbc6959f346cee07a7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_extra_data </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>extra_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__teuchos__mem__mng__grp.html#gacd85ba81c085fde11a3ccc0dfb6f0c5e">EPrePostDestruction</a>&#160;</td>
          <td class="paramname"><em>destroy_when</em> = <code>POST_DESTROY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_unique</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extra_data</td><td>[in] Data object that will be set (copied)</td></tr>
    <tr><td class="paramname">name</td><td>[in] The name given to the extra data. The value of <code>name</code> together with the data type <code>T1</code> of the extra data must be unique from any other such data or the other data will be overwritten.</td></tr>
    <tr><td class="paramname">p</td><td>[out] On output, will be updated with the input <code>extra_data</code></td></tr>
    <tr><td class="paramname">destroy_when</td><td>[in] Determines when <code>extra_data</code> will be destroyed in relation to the underlying reference-counted object. If <code>destroy_when==PRE_DESTROY</code> then <code>extra_data</code> will be deleted before the underlying reference-counted object. If <code>destroy_when==POST_DESTROY</code> (the default) then <code>extra_data</code> will be deleted after the underlying reference-counted object.</td></tr>
    <tr><td class="paramname">force_unique</td><td>[in] Determines if this type and name pair must be unique in which case if an object with this same type and name already exists, then an std::exception will be thrown. The default is <code>true</code> for safety.</td></tr>
  </table>
  </dd>
</dl>
<p>If there is a call to this function with the same type of extra data <code>T1</code> and same arguments <code>p</code> and <code>name</code> has already been made, then the current piece of extra data already set will be overwritten with <code>extra_data</code>. However, if the type of the extra data <code>T1</code> is different, then the extra data can be added and not overwrite existing extra data. This means that extra data is keyed on both the type and name. This helps to minimize the chance that clients will unexpectedly overwrite data by accident.</p>
<p>When the last <code>RefcountPtr</code> object is removed and the reference-count node is deleted, then objects are deleted in the following order: (1) All of the extra data that where added with <code>destroy_when==PRE_DESTROY</code> are first, (2) then the underlying reference-counted object is deleted, and (3) the rest of the extra data that was added with <code>destroy_when==PRE_DESTROY</code> is then deleted. The order in which the objects are destroyed is not guaranteed. Therefore, clients should be careful not to add extra data that has deletion dependancies (instead consider using nested <a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a> objects as extra data which will guarantee the order of deletion).</p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p-&gt;<a class="el" href="classTeuchos_1_1RCP.html#a6c70c3e4073cf89b9ec9d8a3ba15e7fc" title="Get the raw C++ pointer to the underlying object. ">get()</a> != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
<li>
If this function has already been called with the same template type <code>T1</code> for <code>extra_data</code> and the same std::string <code>name</code> and <code>force_unique==true</code>, then an <code>std::invalid_argument</code> std::exception will be thrown. </li>
</ul>
<p>Note, this function is made a non-member function to be consistent with the non-member <code><a class="el" href="classTeuchos_1_1RCP.html#ab7f7cd634c8250ff0515bd55c5f3cde6" title="Get a const reference to extra data associated with a RCP object. ">get_extra_data()</a></code> functions. </p>

</div>
</div>
<a class="anchor" id="ab7f7cd634c8250ff0515bd55c5f3cde6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T1 &amp; get_extra_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
<li>
<code>name</code> and <code>T1</code> must have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object. ">set_extra_data()</a></code> (throws <code>std::invalid_argument</code>). </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a class="anchor" id="a8978c29ca24e96cb61185507a0419dac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 &amp; get_nonconst_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a non-const reference to extra data associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-const reference to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
<li>
<code>name</code> and <code>T1</code> must have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object. ">set_extra_data()</a></code> (throws <code>std::invalid_argument</code>). </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a class="anchor" id="aac70269754b423e8e76d2e75b3dfbf96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const T1 &gt; get_optional_extra_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const pointer to the extra_data object if it exists.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If <code>name</code> and <code>T1</code> have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object. ">set_extra_data()</a></code> then <code>return !=NULL</code> and otherwise <code>return == NULL</code>. </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>

</div>
</div>
<a class="anchor" id="a7b838cf99afd0bb5f2ebc94ab8d73b59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; T1 &gt; get_optional_nonconst_extra_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to non-const extra data (if it exists) associated with a <code><a class="el" href="classTeuchos_1_1RCP.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] Smart pointer object that extra data is being extraced from.</td></tr>
    <tr><td class="paramname">name</td><td>[in] Name of the extra data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-const pointer to the extra_data object.</dd></dl>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If <code>name</code> and <code>T1</code> have been used in a previous call to <code><a class="el" href="classTeuchos_1_1RCP.html#addd19618c28d1cbc6959f346cee07a7f" title="Set extra data associated with a RCP object. ">set_extra_data()</a></code> then <code>return !=NULL</code> and otherwise <code>return == NULL</code>. </li>
</ul>
<p>Note, this function must be a non-member function since the client must manually select the first template argument. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="test_2MemoryManagement_2RCP_test_8cpp-example.html#a18">test/MemoryManagement/RCP_test.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a62a1b34d2efe42b0a0fb4e20c1089f89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dealloc_T , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Dealloc_T &amp; get_dealloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <code>const</code> reference to the underlying deallocator object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
<li>
The deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>

</div>
</div>
<a class="anchor" id="a67483a8eaf4d6a5f234e7bd6c971b009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dealloc_T , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dealloc_T &amp; get_nonconst_dealloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-<code>const</code> reference to the underlying deallocator object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
<li>
The deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>

</div>
</div>
<a class="anchor" id="ac7868e0bffe12f3a8c82daa61cd4cefb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dealloc_T , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const Dealloc_T &gt; get_optional_dealloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the underlying <code>const</code> deallocator object if it exists. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If the deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> then <code>return!=NULL</code>, otherwise <code>return==NULL</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="a40a73590cabeeb6ac3556981e068bd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dealloc_T , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; Dealloc_T &gt; get_optional_nonconst_dealloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the underlying non-<code>const</code> deallocator object if it exists. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>p.get() != NULL</code> (throws <code><a class="el" href="classTeuchos_1_1NullReferenceError.html" title="Null reference error exception class. ">NullReferenceError</a></code>) </li>
</ul>
<p><b>Postconditions:</b></p><ul>
<li>
If the deallocator object type used to construct <code>p</code> is same as <code>Dealloc_T</code> then <code>return!=NULL</code>, otherwise <code>return==NULL</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="afd9ce82fd86820b298f9c3847d585708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOrig , class Embedded , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Embedded &amp; getEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a5dfd3a9f656d730dea2902f08a765811"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOrig , class Embedded , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Embedded &amp; getNonconstEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a non-const reference to an embedded object that was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ae35995646037935daf4f98375cbb7ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOrig , class Embedded , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; const Embedded &gt; getOptionalEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a> to a const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a1fcb0b191b4d3f13cd7e2c139dcc4d8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOrig , class Embedded , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTeuchos_1_1Ptr.html">Ptr</a>&lt; Embedded &gt; getOptionalNonconstEmbeddedObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an optional <a class="el" href="classTeuchos_1_1Ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a> to a non-const embedded object if it was set by calling <code><a class="el" href="classTeuchos_1_1RCP.html#a02148aef172f7b2c0fb2de29cb01b91a" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObjPreDestroy()</a></code>, <code>rcpWithEmbeddedObjPostDestory()</code>, or <code><a class="el" href="classTeuchos_1_1RCP.html#a506210a123b6e1747d910f037065bd73" title="Create an RCP with and also put in an embedded object. ">rcpWithEmbeddedObj()</a></code>. </p>

</div>
</div>
<a class="anchor" id="aa92c7a8fc60f4741319ee31a12a6d75b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTeuchos_1_1RCP.html">RCP</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream inserter. </p>
<p>The implementation of this function just print pointer addresses and therefore puts no restrictions on the data types involved. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Teuchos__ParameterListAcceptor_8hpp_source.html">Teuchos_ParameterListAcceptor.hpp</a></li>
<li><a class="el" href="Teuchos__RCPDecl_8hpp_source.html">Teuchos_RCPDecl.hpp</a></li>
<li><a class="el" href="Teuchos__PtrDecl_8hpp_source.html">Teuchos_PtrDecl.hpp</a></li>
<li><a class="el" href="Teuchos__RCP_8hpp_source.html">Teuchos_RCP.hpp</a></li>
<li><a class="el" href="Teuchos__RCPBoostSharedPtrConversionsDecl_8hpp_source.html">Teuchos_RCPBoostSharedPtrConversionsDecl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
