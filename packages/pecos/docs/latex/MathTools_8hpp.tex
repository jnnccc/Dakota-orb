\section{Math\+Tools.\+hpp File Reference}
\label{MathTools_8hpp}\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}


Miscelaneous math functions.  


\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bfseries lp\+\_\+norm} \{ {\bfseries mt\+\_\+l1\+\_\+norm}, 
{\bfseries mt\+\_\+l2\+\_\+norm}, 
{\bfseries mt\+\_\+linf\+\_\+norm}
 \}\label{MathTools_8hpp_a662cda9bc4cad493eddc78a0a82b2927}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void {\bfseries ind2sub} (const Int\+Vector \&sizes, int index, int num\+\_\+elems, Int\+Vector \&result)
\begin{DoxyCompactList}\small\item\em Map a scalar index of a flat 1D array to the equivalent d-\/dimensional index. \end{DoxyCompactList}\item 
int {\bfseries sub2ind} (const Int\+Vector \&sizes, const Int\+Vector \&multi\+\_\+index)
\begin{DoxyCompactList}\small\item\em Map a d-\/dimensional index to the scalar index of the equivalent flat 1D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_a3731ebd8f88288feeadbf520bf87b5d2}{cartesian\+\_\+product} (const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&input\+\_\+sets, Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&result, int elem\+\_\+size)
\begin{DoxyCompactList}\small\item\em Compute the cartesian product of an arbitray number of sets. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_acb4af3a3f366ed9ad56f9ff808ab179e}{outer\+\_\+product} (const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&input\+\_\+sets, Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&result)
\begin{DoxyCompactList}\small\item\em Construct the outer product of an arbitray number of sets. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_a10c289ea3f98707b1e460afa67c204e8}{range} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&result, T m, T n, T incr=1)
\begin{DoxyCompactList}\small\item\em Build a vector containing all integers in \mbox{[}m,n) seperated by incr. \end{DoxyCompactList}\item 
void {\bfseries linspace} (Real\+Vector \&result, Real a, Real b, int n)
\begin{DoxyCompactList}\small\item\em Generate a vector whose n elements are equidistantly spaced in the interval \mbox{[}a,b\mbox{]}. \end{DoxyCompactList}\item 
Real {\bfseries round} (Real r)\label{MathTools_8cpp_a37b8d84daec6e1d721a07e76e68564ed}

\begin{DoxyCompactList}\small\item\em Round a Real to the nearest integer. \end{DoxyCompactList}\item 
bool {\bfseries abs\+\_\+compare} (Real a, Real b)\label{MathTools_8cpp_a3e719cc805d48d79f06b2e398002884c}

\item 
int {\bfseries nearest\+\_\+integer} (Real x)
\begin{DoxyCompactList}\small\item\em Return the nearest integer to x. \end{DoxyCompactList}\item 
Real {\bfseries factorial} (int n)
\begin{DoxyCompactList}\small\item\em Calulate n! \end{DoxyCompactList}\item 
int {\bfseries nchoosek} (int n, int k)
\begin{DoxyCompactList}\small\item\em Return the number of possible combinations of k elements that can be chosen from n elements. \end{DoxyCompactList}\item 
Real {\bfseries rescale} (Real x, Real a, Real b, int dir)
\begin{DoxyCompactList}\small\item\em Transform a point x in the interval \mbox{[}a,b\mbox{]} onto the interval \mbox{[}0,1\mbox{]} and vice versa. \end{DoxyCompactList}\item 
void {\bfseries rescale} (Real\+Matrix \&x, const Real\+Vector \&domain, int dir)
\begin{DoxyCompactList}\small\item\em Transform a point x in the interval $[a_1,b_1] \times \cdots \times [a_d,b_d] $ onto the hypercube interval $[0,1]^d$ and vice versa. \end{DoxyCompactList}\item 
void {\bfseries hypercube\+\_\+map} (Real\+Matrix \&x, const Real\+Vector \&domain\+\_\+in, const Real\+Vector \&domain\+\_\+out, Real\+Matrix \&result)\label{MathTools_8cpp_a2178174c4b32bc1ffb3553791ed95183}

\begin{DoxyCompactList}\small\item\em transform points in domain\+\_\+in to points in domain\+\_\+out \end{DoxyCompactList}\item 
void {\bfseries mesh\+\_\+grid} (const Int\+Vector \&num\+\_\+pts\+\_\+1d, const Real\+Vector \&domain, Real\+Matrix \&result)
\begin{DoxyCompactList}\small\item\em Construct a d-\/dimensional mesh on a hyper-\/rectangle. The meshes are equidistant with respect to each coordinate direction. \end{DoxyCompactList}\item 
void {\bfseries get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices} (Int\+Matrix \&B, int $\ast$elems, int len\+\_\+elems, int $\ast$pos, int len\+\_\+pos, int choices\+\_\+made, int first\+\_\+pos, int order, int \&col)
\item 
void {\bfseries get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices} (int num\+\_\+dims, int degree, Int\+Matrix \&result)
\begin{DoxyCompactList}\small\item\em Get all the multi-\/dimensional indices of a multi-\/dimensional polynomial basis with a specified degree sum. \end{DoxyCompactList}\item 
int {\bfseries get\+\_\+total\+\_\+degree\+\_\+from\+\_\+num\+\_\+samples} (int num\+\_\+dims, int num\+\_\+samples)\label{MathTools_8cpp_a12ce4303082f09848959a4b6c97f0b62}

\begin{DoxyCompactList}\small\item\em Get the smallest degree of the total degree polynomial such that the number of terms in the basis is larger than or equal to num\+\_\+samples. \end{DoxyCompactList}\item 
void {\bfseries set\+\_\+hypercube\+\_\+domain} (Real\+Vector \&result, int num\+\_\+dims, Real a, Real b)
\begin{DoxyCompactList}\small\item\em Get the multi-\/dimensional hypercube $[a,b]^d$. \end{DoxyCompactList}\item 
void {\bfseries get\+\_\+permutations} (Int\+Matrix \&permutations, int M, int N, unsigned int seed)\label{MathTools_8cpp_a32764e08b89bb03e1a8d664bd173f2fb}

\begin{DoxyCompactList}\small\item\em Perturb the columns of a matrix. \end{DoxyCompactList}\item 
void {\bfseries compute\+\_\+hyperbolic\+\_\+level\+\_\+subdim\+\_\+indices} (int num\+\_\+dims, int level, int num\+\_\+active\+\_\+dims, Real p, Int\+Matrix \&indices)\label{MathTools_8cpp_a2d19e5607ec804c7aea5d72bbb6d5ee2}

\item 
void {\bfseries compute\+\_\+hyperbolic\+\_\+level\+\_\+indices} (int num\+\_\+dims, int level, Real p, Int\+Matrix \&indices)\label{MathTools_8cpp_aaa76922a307be0a1036eb021c2c1e098}

\item 
void {\bfseries compute\+\_\+hyperbolic\+\_\+indices} (int num\+\_\+dims, int level, Real p, Int\+Matrix \&indices)\label{MathTools_8cpp_abdb101758a21f0573a95e255fd8cadaa}

\item 
void {\bfseries compute\+\_\+anisotropic\+\_\+hyperbolic\+\_\+indices} (int num\+\_\+dims, int level, Real p, Real\+Vector \&weights, Int\+Matrix \&indices)\label{MathTools_8cpp_afdee9e6de3a413adf7ae2c94ad189e57}

\item 
{\footnotesize template$<$typename T $>$ }\\int \hyperlink{MathTools_8hpp_a84e06f141aa8d0e6d076c5176c17107d}{argmin} (int n, T $\ast$x)
\begin{DoxyCompactList}\small\item\em Return the index of the element of x with the minimum value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\int \hyperlink{MathTools_8hpp_a7d0662e44ce4fd29e278afcea55f908b}{argmax} (int n, T $\ast$x)
\begin{DoxyCompactList}\small\item\em Return the index of the element of x with the maximum value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\int {\bfseries magnitude\+\_\+argmax} (int n, T $\ast$x)\label{MathTools_8hpp_a66516a769717c1c801554ff29a832c37}

\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{MathTools_8hpp_ad797845782ceb94ba49a0e99685c1693}{sum} (int n, T $\ast$x)
\begin{DoxyCompactList}\small\item\em Return the sum of the elements in the array x. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\T \hyperlink{MathTools_8hpp_a0c1d929851ac321e7d78f4392f770b3d}{sum} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)
\begin{DoxyCompactList}\small\item\em Return the sum of the elements in the vector x. \end{DoxyCompactList}\item 
Real {\bfseries mean} (int n, Real $\ast$x)
\begin{DoxyCompactList}\small\item\em Return the mean of the array x. \end{DoxyCompactList}\item 
Real {\bfseries variance} (int n, Real $\ast$x, int ddof=1)
\begin{DoxyCompactList}\small\item\em Return the sample variance of the array x. \end{DoxyCompactList}\item 
void {\bfseries lp\+\_\+error} (Real\+Matrix \&reference\+\_\+values, Real\+Matrix \&approximate\+\_\+values, std\+::vector$<$ lp\+\_\+norm $>$ error\+\_\+norms, Real\+Matrix \&error, Int\+Vector \&active\+\_\+columns, bool normalise=false)
\begin{DoxyCompactList}\small\item\em Calculate one of several different types of $\ell_p$ error norms of a set of vectors. \end{DoxyCompactList}\item 
void {\bfseries latin\+\_\+hypercube\+\_\+design} (int num\+\_\+pts, int num\+\_\+dims, Real\+Matrix \&result, int seed)\label{MathTools_8cpp_a8625933001446106e49a0bfbcc3e5ab8}

\begin{DoxyCompactList}\small\item\em Construct a Latin Hyperube Design (L\+HD) \end{DoxyCompactList}\item 
void {\bfseries compute\+\_\+next\+\_\+combination} (int num\+\_\+dims, int level, Int\+Vector \&index, bool \&extend, int \&h, int \&t)\label{MathTools_8cpp_aaf9fa0051222cece664834a29a049519}

\item 
void {\bfseries compute\+\_\+combinations} (int num\+\_\+dims, int level, Int\+Matrix \&indices)\label{MathTools_8cpp_a4b196d6bfb94ef8e94dc80da8ad1e6ac}

\item 
{\footnotesize template$<$typename T $>$ }\\int \hyperlink{MathTools_8hpp_a5a36d0eca26979a57433f9117966d2de}{sgn} (T x)
\item 
{\footnotesize template$<$typename T $>$ }\\int {\bfseries num\+\_\+non\+\_\+zeros} (T $\ast$data, int n)\label{MathTools_8hpp_a1db03675f04c05ba95474196ace8fd58}

\item 
{\footnotesize template$<$typename T $>$ }\\double \hyperlink{MathTools_8hpp_a87866c9f8de7a65811d08ca5b8ad220b}{median} (std\+::vector$<$ T $>$ \&v)\label{MathTools_8hpp_a87866c9f8de7a65811d08ca5b8ad220b}

\begin{DoxyCompactList}\small\item\em return the median of a std\+::vector \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\double \hyperlink{MathTools_8hpp_ae27ba4fdb3ecee5e5e8f14826556afd6}{median} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)\label{MathTools_8hpp_ae27ba4fdb3ecee5e5e8f14826556afd6}

\begin{DoxyCompactList}\small\item\em return the median of a Real\+Vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\double {\bfseries pnorm} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v, double p)\label{MathTools_8hpp_aec4bc2dde1bf8e981f334428b7f60f02}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\O {\bfseries num\+\_\+nonzeros} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)\label{MathTools_8hpp_a9f303c0256779163b65cdb4981e2e5ad}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void {\bfseries nonzero} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v, Int\+Vector \&result)\label{MathTools_8hpp_abb2c01c421b8d27a1353b7ec83de6353}

\item 
void {\bfseries lhs\+\_\+indices} (int num\+\_\+dims, int num\+\_\+pts, int duplication, int seed, Int\+Matrix \&result)\label{MathTools_8hpp_a7d4af51c9ce21b69723c17d310c9b3d5}

\item 
void \hyperlink{MathTools_8hpp_a281b3cc477a9f7cb2f8a0521b136f47f}{ilhs} (int num\+\_\+dims, int num\+\_\+pts, int duplication, int seed, Real\+Matrix \&result)\label{MathTools_8hpp_a281b3cc477a9f7cb2f8a0521b136f47f}

\begin{DoxyCompactList}\small\item\em Construct the improved distributed hypercube sample. \end{DoxyCompactList}\item 
void \hyperlink{MathTools_8hpp_ad630759c81fad6ef75633fac88b064ad}{lhs} (int num\+\_\+dims, int num\+\_\+pts, int seed, Real\+Matrix \&result)\label{MathTools_8hpp_ad630759c81fad6ef75633fac88b064ad}

\begin{DoxyCompactList}\small\item\em Construct basic random hypercube sample. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void {\bfseries argsort} (const Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&values, Int\+Vector \&result)\label{MathTools_8hpp_a61ee7b3724dafed39e286d2561ef0f12}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void {\bfseries argsort} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v, Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&result\+\_\+0, Int\+Vector \&result\+\_\+1)\label{MathTools_8hpp_aa7a2b4ea5bcce643f20c95cf204c204f}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void {\bfseries magnitude\+\_\+argsort} (const Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&values, Int\+Vector \&result)\label{MathTools_8hpp_a2fcd2e5fbcd1cfe118cc2b9011095284}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\int \hyperlink{MathTools_8hpp_a5b7825c8b05353d9d19f4f9afff064d6}{binary\+\_\+search} (T target, Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&data)\label{MathTools_8hpp_a5b7825c8b05353d9d19f4f9afff064d6}

\begin{DoxyCompactList}\small\item\em find the interval containing a target value. Assumes data is in ascending order \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_aead46682ff85de914142151a1c132a54}{reverse} (Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)
\begin{DoxyCompactList}\small\item\em Reverse the contents of a vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void {\bfseries set\+\_\+difference\+\_\+matrix\+\_\+columns} (const Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&A, const Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&B, Int\+Vector \&result)\label{MathTools_8hpp_a7d0f50717ee3e565b81d5e37567b219d}

\item 
{\footnotesize template$<$typename Matrix\+Type $>$ }\\void {\bfseries extract\+\_\+submatrix\+\_\+from\+\_\+column\+\_\+indices} (const Matrix\+Type \&A, const Int\+Vector \&column\+\_\+indices, Matrix\+Type \&submatrix)\label{MathTools_8hpp_a0fe073268987984f71dcba546e7485a2}

\item 
{\footnotesize template$<$typename Matrix\+Type $>$ }\\void {\bfseries copy\+\_\+matrix} (const Matrix\+Type \&source, Matrix\+Type \&dest, int num\+\_\+rows, int num\+\_\+cols, int start\+\_\+row=0, int start\+\_\+col=0)\label{MathTools_8hpp_a5a130c2bd6bc39b8d5ea23a19f450531}

\item 
{\footnotesize template$<$typename Vector\+Type $>$ }\\void {\bfseries copy\+\_\+vector} (const Vector\+Type \&source, Vector\+Type \&dest, int num\+\_\+rows, int start\+\_\+row=0)\label{MathTools_8hpp_a0017b38c2c5f60851351c569c56e8fed}

\item 
{\footnotesize template$<$typename Matrix\+Type $>$ }\\void {\bfseries hstack} (const Matrix\+Type \&source1, const Matrix\+Type \&source2, Matrix\+Type \&dest)\label{MathTools_8hpp_a5197f0e751bf76751c2afc32667b5762}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_ac949ae4248474a32c99b3463f24b0b7a}{convert} (T a\mbox{[}$\,$\mbox{]}, int m, int n, std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&v)
\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_a87a9e0561e70289efe24bf0fbbbddcec}{convert} (T a\mbox{[}$\,$\mbox{]}, int m, int n, std\+::set$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&s)
\item 
{\footnotesize template$<$typename O , typename T $>$ }\\void \hyperlink{MathTools_8hpp_a9534dfa37a95edeef7cca8d3e0aa0f5d}{convert} (const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&V, Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&M)
\begin{DoxyCompactList}\small\item\em Convert a std\+::vector of vectors to a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Operator $>$ }\\void \hyperlink{MathTools_8hpp_ab2eea3aedce948033aa263ee5811afc9}{accumulate} (const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&vectors, std\+::vector$<$ T $>$ \&result, Operator op)
\item 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries is\+\_\+nan\+\_\+or\+\_\+inf} (T x)\label{MathTools_8hpp_a0ae6977f6593806c6588946c94c7a2e0}

\item 
{\footnotesize template$<$typename O , typename T $>$ }\\bool {\bfseries has\+\_\+nan\+\_\+or\+\_\+inf} (const Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&matrix)\label{MathTools_8hpp_ae6659acbddaf7318a09b9d30a14d836b}

\item 
void {\bfseries get\+\_\+column\+\_\+norms} (Real\+Matrix \&A, Real\+Vector \&result)\label{MathTools_8cpp_a56e4493e43e1fbaba0ae19a4862069af}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Miscelaneous math functions. 

\begin{DoxyAuthor}{Author}
John D. Jakeman 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
31 October 2011 
\end{DoxyDate}


\subsection{Function Documentation}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!ind2sub@{ind2sub}}
\index{ind2sub@{ind2sub}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{ind2sub(const Int\+Vector \&sizes, int index, int num\+\_\+elems, Int\+Vector \&result)}{ind2sub(const IntVector &sizes, int index, int num_elems, IntVector &result)}}]{\setlength{\rightskip}{0pt plus 5cm}void ind2sub (
\begin{DoxyParamCaption}
\item[{const Int\+Vector \&}]{sizes, }
\item[{int}]{index, }
\item[{int}]{num\+\_\+elems, }
\item[{Int\+Vector \&}]{result}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a3287c7018328e373a949fb2180496c74}


Map a scalar index of a flat 1D array to the equivalent d-\/dimensional index. 

Example\+: \[ \begin{bmatrix} 1 & 4 & 7\\ 2 & 5 & 8\\ 3 & 6 & 9 \end{bmatrix} \rightarrow \begin{bmatrix} 1,1 & 1,2 & 1,3\\ 2,1 & 2,2 & 2,3\\ 3,1 & 3,2 & 3,3 \end{bmatrix} \]


\begin{DoxyParams}{Parameters}
{\em sizes} & the number of elems in each dimension. For a 2D index sizes = \mbox{[}num\+Rows, num\+Cols\mbox{]} \\
\hline
{\em index} & the scalar index \\
\hline
{\em num\+\_\+elems} & the total number of elements in the d-\/dimensional matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
result the d-\/dimensional index 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!sub2ind@{sub2ind}}
\index{sub2ind@{sub2ind}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{sub2ind(const Int\+Vector \&sizes, const Int\+Vector \&multi\+\_\+index)}{sub2ind(const IntVector &sizes, const IntVector &multi_index)}}]{\setlength{\rightskip}{0pt plus 5cm}int sub2ind (
\begin{DoxyParamCaption}
\item[{const Int\+Vector \&}]{sizes, }
\item[{const Int\+Vector \&}]{multi\+\_\+index}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a1e76956d44fab9e2c30828063c23895a}


Map a d-\/dimensional index to the scalar index of the equivalent flat 1D array. 

Example\+: \[ \begin{bmatrix} 1,1 & 1,2 & 1,3\\ 2,1 & 2,2 & 2,3\\ 3,1 & 3,2 & 3,3 \end{bmatrix} \rightarrow \begin{bmatrix} 1 & 4 & 7\\ 2 & 5 & 8\\ 3 & 6 & 9 \end{bmatrix} \]


\begin{DoxyParams}{Parameters}
{\em sizes} & the number of elems in each dimension. For a 2D index sizes = \mbox{[}num\+Rows, num\+Cols\mbox{]} \\
\hline
{\em multi\+\_\+index} & the d-\/dimensional index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
scalar\+\_\+index the scalar index of the flat array 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!cartesian\+\_\+product@{cartesian\+\_\+product}}
\index{cartesian\+\_\+product@{cartesian\+\_\+product}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{cartesian\+\_\+product(const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&input\+\_\+sets, Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&result, int elem\+\_\+size)}{cartesian_product(const std::vector< Teuchos::SerialDenseVector< O, T > > &input_sets, Teuchos::SerialDenseMatrix< O, T > &result, int elem_size)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::cartesian\+\_\+product (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&}]{input\+\_\+sets, }
\item[{Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&}]{result, }
\item[{int}]{elem\+\_\+size}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a3731ebd8f88288feeadbf520bf87b5d2}


Compute the cartesian product of an arbitray number of sets. 

These sets can consist of numbers of be themselves sets of vectors 
\begin{DoxyParams}{Parameters}
{\em input\+Sets} & the sets to be used in the cartesian product \\
\hline
{\em elem\+\_\+size} & the size of the vectors within each set. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the cartesian product 
\end{DoxyReturn}


References Pecos\+::cartesian\+\_\+product().



Referenced by Pecos\+::cartesian\+\_\+product(), and Regress\+Orthog\+Poly\+Approximation\+::grid\+Search\+Function().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!outer\+\_\+product@{outer\+\_\+product}}
\index{outer\+\_\+product@{outer\+\_\+product}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{outer\+\_\+product(const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&input\+\_\+sets, Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&result)}{outer_product(const std::vector< Teuchos::SerialDenseVector< O, T > > &input_sets, Teuchos::SerialDenseVector< O, T > &result)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::outer\+\_\+product (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&}]{input\+\_\+sets, }
\item[{Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&}]{result}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_acb4af3a3f366ed9ad56f9ff808ab179e}


Construct the outer product of an arbitray number of sets. 

Example\+: \[ \{1,2\}\times\{3,4\}=\{1\times3, 2\times3, 1\times4, 2\times4\} = \{3, 6, 4, 8\} \] 
\begin{DoxyParams}{Parameters}
{\em input\+\_\+sets} & \char`\"{}\+Vector.\+hpp\char`\"{} of sets to be used in the outer product \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
result the outer product 
\end{DoxyReturn}


References Pecos\+::outer\+\_\+product().



Referenced by Pecos\+::outer\+\_\+product().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!range@{range}}
\index{range@{range}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{range(\+Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&result, T m, T n, T incr=1)}{range(Teuchos::SerialDenseVector< O, T > &result, T m, T n, T incr=1)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::range (
\begin{DoxyParamCaption}
\item[{Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&}]{result, }
\item[{T}]{m, }
\item[{T}]{n, }
\item[{T}]{incr = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a10c289ea3f98707b1e460afa67c204e8}


Build a vector containing all integers in \mbox{[}m,n) seperated by incr. 

E.\+g Range( 1, 10, 2 ) -\/$>$ \mbox{[}1,3,5,7,9\mbox{]} 

References Pecos\+::range().



Referenced by Regress\+Orthog\+Poly\+Approximation\+::compressed\+\_\+sensing(), Loguniform\+Random\+Variable\+::dz\+\_\+ds\+\_\+factor(), Beta\+Random\+Variable\+::pdf(), Triangular\+Random\+Variable\+::pdf\+\_\+gradient(), Pecos\+::range(), Pecos\+::reverse(), Loguniform\+Random\+Variable\+::standard\+\_\+deviation(), Beta\+Random\+Variable\+::update\+\_\+boost(), Loguniform\+Random\+Variable\+::variance(), Uniform\+Random\+Variable\+::variance(), and Beta\+Random\+Variable\+::variance().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!linspace@{linspace}}
\index{linspace@{linspace}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{linspace(\+Real\+Vector \&result, Real a, Real b, int n)}{linspace(RealVector &result, Real a, Real b, int n)}}]{\setlength{\rightskip}{0pt plus 5cm}void linspace (
\begin{DoxyParamCaption}
\item[{Real\+Vector \&}]{result, }
\item[{Real}]{a, }
\item[{Real}]{b, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_af1110de2b0758beb2395f3fb91222a68}


Generate a vector whose n elements are equidistantly spaced in the interval \mbox{[}a,b\mbox{]}. 


\begin{DoxyParams}{Parameters}
{\em \mbox{[}a,b\mbox{]}} & the range \\
\hline
{\em n} & the number of times the interval \mbox{[}a,b\mbox{]} is divided \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
vec n numbers equidistant is \mbox{[}a,b\mbox{]} 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!nearest\+\_\+integer@{nearest\+\_\+integer}}
\index{nearest\+\_\+integer@{nearest\+\_\+integer}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{nearest\+\_\+integer(\+Real x)}{nearest_integer(Real x)}}]{\setlength{\rightskip}{0pt plus 5cm}int nearest\+\_\+integer (
\begin{DoxyParamCaption}
\item[{Real}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a47978666d8fe3e67590714df569e1b17}


Return the nearest integer to x. 


\begin{DoxyParams}{Parameters}
{\em x} & the value return int the neartest integer to x \\
\hline
\end{DoxyParams}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!factorial@{factorial}}
\index{factorial@{factorial}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{factorial(int n)}{factorial(int n)}}]{\setlength{\rightskip}{0pt plus 5cm}Real factorial (
\begin{DoxyParamCaption}
\item[{int}]{n}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_ad41880981584823e19900d7f4e359e44}


Calulate n! 


\begin{DoxyParams}{Parameters}
{\em n} & the factorial of interest \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
n! 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!nchoosek@{nchoosek}}
\index{nchoosek@{nchoosek}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{nchoosek(int n, int k)}{nchoosek(int n, int k)}}]{\setlength{\rightskip}{0pt plus 5cm}int nchoosek (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_ab5c39f309363fcfdb201ce84e71a853b}


Return the number of possible combinations of k elements that can be chosen from n elements. 

\[ { n \choose k} = \frac{n!}{k!(n-k)!}\] 
\begin{DoxyParams}{Parameters}
{\em n} & number of elements \\
\hline
{\em k} & the number of elements to be chosen. k$<$=n. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the total number of combinations. 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!rescale@{rescale}}
\index{rescale@{rescale}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{rescale(\+Real x, Real a, Real b, int dir)}{rescale(Real x, Real a, Real b, int dir)}}]{\setlength{\rightskip}{0pt plus 5cm}Real rescale (
\begin{DoxyParamCaption}
\item[{Real}]{x, }
\item[{Real}]{a, }
\item[{Real}]{b, }
\item[{int}]{dir}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a753dc82fd47387c45a64c14294120811}


Transform a point x in the interval \mbox{[}a,b\mbox{]} onto the interval \mbox{[}0,1\mbox{]} and vice versa. 


\begin{DoxyParams}{Parameters}
{\em x} & the value to be transformed \\
\hline
{\em \mbox{[}a,b\mbox{]}} & the new/old interval \\
\hline
{\em dir} & specifies whether to map to \mbox{[}a,b\mbox{]} or from \mbox{[}a,b\mbox{]}. That is dir=0 returns \mbox{[}0,1\mbox{]} -\/$>$ \mbox{[}a,b\mbox{]} dir!=0 returns \mbox{[}a,b\mbox{]} -\/$>$ \mbox{[}0,1\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the rescaled value 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!rescale@{rescale}}
\index{rescale@{rescale}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{rescale(\+Real\+Matrix \&x, const Real\+Vector \&domain, int dir)}{rescale(RealMatrix &x, const RealVector &domain, int dir)}}]{\setlength{\rightskip}{0pt plus 5cm}void rescale (
\begin{DoxyParamCaption}
\item[{Real\+Matrix \&}]{x, }
\item[{const Real\+Vector \&}]{domain, }
\item[{int}]{dir}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a47a1c25eee29f9ce95f7d57b0b5e8c16}


Transform a point x in the interval $[a_1,b_1] \times \cdots \times [a_d,b_d] $ onto the hypercube interval $[0,1]^d$ and vice versa. 


\begin{DoxyParams}{Parameters}
{\em x} & the value to be transformed \\
\hline
{\em \mbox{[}a,b\mbox{]}} & the new/old interval \\
\hline
{\em dir} & specifies whether to map to \mbox{[}a,b\mbox{]} or from \mbox{[}a,b\mbox{]}. That is dir=0 returns \mbox{[}0,1\mbox{]} -\/$>$ \mbox{[}a,b\mbox{]} dir!=0 returns \mbox{[}a,b\mbox{]} -\/$>$ \mbox{[}0,1\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the rescaled value 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!mesh\+\_\+grid@{mesh\+\_\+grid}}
\index{mesh\+\_\+grid@{mesh\+\_\+grid}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{mesh\+\_\+grid(const Int\+Vector \&num\+\_\+pts\+\_\+1d, const Real\+Vector \&domain, Real\+Matrix \&result)}{mesh_grid(const IntVector &num_pts_1d, const RealVector &domain, RealMatrix &result)}}]{\setlength{\rightskip}{0pt plus 5cm}void mesh\+\_\+grid (
\begin{DoxyParamCaption}
\item[{const Int\+Vector \&}]{num\+\_\+pts\+\_\+1d, }
\item[{const Real\+Vector \&}]{domain, }
\item[{Real\+Matrix \&}]{result}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_ab2497f4c0c6c1339b36956587ee1467d}


Construct a d-\/dimensional mesh on a hyper-\/rectangle. The meshes are equidistant with respect to each coordinate direction. 


\begin{DoxyParams}{Parameters}
{\em num\+\_\+pts\+\_\+1d} & array specifying the number of meshpoints for each dimension \\
\hline
{\em domain} & the min and max value of each dimension. That is $ [a_1,b_1,...,a_d,b_d]$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the multi-\/dimensional mesh coordinates. ( num\+\_\+dims x num\+\_\+pts ) array. num\+\_\+pts = num\+\_\+pts\+\_\+1d\mbox{[}0\mbox{]}$\ast$...$\ast$num\+\_\+pts\+\_\+1d\mbox{[}d-\/1\mbox{]} 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices@{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices}}
\index{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices@{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices(\+Int\+Matrix \&\+B, int $\ast$elems, int len\+\_\+elems, int $\ast$pos, int len\+\_\+pos, int choices\+\_\+made, int first\+\_\+pos, int order, int \&col)}{get_multi_dimensional_polynomial_subspace_indices(IntMatrix &B, int *elems, int len_elems, int *pos, int len_pos, int choices_made, int first_pos, int order, int &col)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+subspace\+\_\+indices (
\begin{DoxyParamCaption}
\item[{Int\+Matrix \&}]{B, }
\item[{int $\ast$}]{elems, }
\item[{int}]{len\+\_\+elems, }
\item[{int $\ast$}]{pos, }
\item[{int}]{len\+\_\+pos, }
\item[{int}]{choices\+\_\+made, }
\item[{int}]{first\+\_\+pos, }
\item[{int}]{order, }
\item[{int \&}]{row}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a8807d4d0fdee16e1a134de73eacd1b33}
Get all the multi-\/dimensional indices of a multi-\/dimensional polynomial basis with a specified degree sum. A cleaner interface is provided by Get\+Multi\+Dimensional\+Polynomial\+\_\+indices() \begin{DoxyReturn}{Returns}
B the multi-\/dimensional indices 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices@{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices}}
\index{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices@{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices(int num\+\_\+dims, int degree, Int\+Matrix \&result)}{get_multi_dimensional_polynomial_indices(int num_dims, int degree, IntMatrix &result)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+\_\+multi\+\_\+dimensional\+\_\+polynomial\+\_\+indices (
\begin{DoxyParamCaption}
\item[{int}]{num\+\_\+dims, }
\item[{int}]{degree, }
\item[{Int\+Matrix \&}]{result}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a838079f730c2b4462b372c80e8911237}


Get all the multi-\/dimensional indices of a multi-\/dimensional polynomial basis with a specified degree sum. 


\begin{DoxyParams}{Parameters}
{\em num\+\_\+dims} & the dimensionailty \\
\hline
{\em degree} & the degree sum of the polynomial indices wanted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
B the multi-\/dimensional polynomial\+\_\+indices 
\end{DoxyReturn}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!set\+\_\+hypercube\+\_\+domain@{set\+\_\+hypercube\+\_\+domain}}
\index{set\+\_\+hypercube\+\_\+domain@{set\+\_\+hypercube\+\_\+domain}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{set\+\_\+hypercube\+\_\+domain(\+Real\+Vector \&result, int num\+\_\+dims, Real a, Real b)}{set_hypercube_domain(RealVector &result, int num_dims, Real a, Real b)}}]{\setlength{\rightskip}{0pt plus 5cm}void set\+\_\+hypercube\+\_\+domain (
\begin{DoxyParamCaption}
\item[{Real\+Vector \&}]{result, }
\item[{int}]{num\+\_\+dims, }
\item[{Real}]{a, }
\item[{Real}]{b}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a1fcf1931725575d98a96ca50c45b706d}


Get the multi-\/dimensional hypercube $[a,b]^d$. 


\begin{DoxyParams}{Parameters}
{\em num\+\_\+dims} & the dimension of the computational domain. \\
\hline
{\em } & \\
\hline
\end{DoxyParams}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!argmin@{argmin}}
\index{argmin@{argmin}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{argmin(int n, T $\ast$x)}{argmin(int n, T *x)}}]{\setlength{\rightskip}{0pt plus 5cm}int Pecos\+::argmin (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{T $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a84e06f141aa8d0e6d076c5176c17107d}


Return the index of the element of x with the minimum value. 

\[ \arg \! \min_i x_i\quad i=1,\ldots,n \] 

References Pecos\+::argmin().



Referenced by Pecos\+::argmin().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!argmax@{argmax}}
\index{argmax@{argmax}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{argmax(int n, T $\ast$x)}{argmax(int n, T *x)}}]{\setlength{\rightskip}{0pt plus 5cm}int Pecos\+::argmax (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{T $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a7d0662e44ce4fd29e278afcea55f908b}


Return the index of the element of x with the maximum value. 

\[ \arg \! \max_i x_i \quad i=1,\ldots,n \] 

References Pecos\+::argmax().



Referenced by Pecos\+::argmax().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!sum@{sum}}
\index{sum@{sum}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{sum(int n, T $\ast$x)}{sum(int n, T *x)}}]{\setlength{\rightskip}{0pt plus 5cm}T Pecos\+::sum (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{T $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_ad797845782ceb94ba49a0e99685c1693}


Return the sum of the elements in the array x. 

\[ \sum_{i=1}^N x_i \] 

References Pecos\+::sum().



Referenced by Numeric\+Gen\+Orthog\+Polynomial\+::cc\+\_\+bounded\+\_\+integral(), Numeric\+Gen\+Orthog\+Polynomial\+::fejer\+\_\+semibounded\+\_\+integral(), Numeric\+Gen\+Orthog\+Polynomial\+::fejer\+\_\+unbounded\+\_\+integral(), Orthogonal\+Polynomial\+::gauss\+\_\+check(), Numeric\+Gen\+Orthog\+Polynomial\+::hermite\+\_\+unbounded\+\_\+integral(), Numeric\+Gen\+Orthog\+Polynomial\+::inner\+\_\+product(), Numeric\+Gen\+Orthog\+Polynomial\+::laguerre\+\_\+semibounded\+\_\+integral(), Numeric\+Gen\+Orthog\+Polynomial\+::legendre\+\_\+bounded\+\_\+integral(), Histogram\+Bin\+Random\+Variable\+::mean(), Pecos\+::median(), Pecos\+::sum(), and Lagrange\+Interp\+Polynomial\+::type1\+\_\+gradient().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!sum@{sum}}
\index{sum@{sum}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{sum(\+Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)}{sum(Teuchos::SerialDenseVector< O, T > &v)}}]{\setlength{\rightskip}{0pt plus 5cm}T Pecos\+::sum (
\begin{DoxyParamCaption}
\item[{Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&}]{v}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a0c1d929851ac321e7d78f4392f770b3d}


Return the sum of the elements in the vector x. 

\[ \sum_{i=1}^N x_i \]

This will not return the same result as sum( int n, T$\ast$ x ) if the vector is a subvector of another vector. That is stride does not equal the number of rows. 

References Pecos\+::sum().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!mean@{mean}}
\index{mean@{mean}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{mean(int n, Real $\ast$x)}{mean(int n, Real *x)}}]{\setlength{\rightskip}{0pt plus 5cm}Real mean (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{Real $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a0f297b8a3d8ec9ddf7adea40ee8e4f81}


Return the mean of the array x. 

\[ \bar{x} = \frac{1}{N}\sum_{i=1}^N x_i \] \index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!variance@{variance}}
\index{variance@{variance}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{variance(int n, Real $\ast$x, int ddof=1)}{variance(int n, Real *x, int ddof=1)}}]{\setlength{\rightskip}{0pt plus 5cm}Real variance (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{Real $\ast$}]{x, }
\item[{int}]{ddof = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_abb927ad377becfe4ecafbb0b3b21603f}


Return the sample variance of the array x. 

\[ \sigma^2 = \frac{1}{N-\text{ddof}}\sum_{i=1}^N ( x_i-\bar{x} )^2 \]


\begin{DoxyParams}{Parameters}
{\em ddof} & Delta Degrees of Freedom (ddof). The divisor used in calculations is $N - \text{ddof}$, where \$fN\$f represents the number of elements. By default ddof is one. \\
\hline
\end{DoxyParams}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!lp\+\_\+error@{lp\+\_\+error}}
\index{lp\+\_\+error@{lp\+\_\+error}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{lp\+\_\+error(\+Real\+Matrix \&reference\+\_\+values, Real\+Matrix \&approximate\+\_\+values, std\+::vector$<$ lp\+\_\+norm $>$ error\+\_\+norms, Real\+Matrix \&error, Int\+Vector \&active\+\_\+columns, bool normalise=false)}{lp_error(RealMatrix &reference_values, RealMatrix &approximate_values, std::vector< lp_norm > error_norms, RealMatrix &error, IntVector &active_columns, bool normalise=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void lp\+\_\+error (
\begin{DoxyParamCaption}
\item[{Real\+Matrix \&}]{reference\+\_\+values, }
\item[{Real\+Matrix \&}]{approximate\+\_\+values, }
\item[{std\+::vector$<$ lp\+\_\+norm $>$}]{error\+\_\+norms, }
\item[{Real\+Matrix \&}]{error, }
\item[{Int\+Vector \&}]{active\+\_\+columns, }
\item[{bool}]{normalise = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{MathTools_8cpp_file_a3cbd72b5245c02f720695dd567e37c0b}


Calculate one of several different types of $\ell_p$ error norms of a set of vectors. 

Each column of the reference\+\_\+values matrix is considered independently with the correpsonding column in the approximation\+\_\+values. The error between the each set of two columns tested is returned. 
\begin{DoxyParams}{Parameters}
{\em reference\+\_\+values} & a matrix containing the reference values \\
\hline
{\em approximate\+\_\+values} & a matrix containig the approximate values \\
\hline
{\em active\+\_\+columns} & specifies which set of columns to consider. If empty all columns are considered  normalise if true the error norms are normalised. The l\+\_\+inf norm is normalised by the half the range of the data in the reference\+\_\+values column. The L\+\_\+2 norm is normalised by the standard deviation of the data in the reference values column. \\
\hline
\end{DoxyParams}
\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!sgn@{sgn}}
\index{sgn@{sgn}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{sgn(\+T x)}{sgn(T x)}}]{\setlength{\rightskip}{0pt plus 5cm}int Pecos\+::sgn (
\begin{DoxyParamCaption}
\item[{T}]{x}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a5a36d0eca26979a57433f9117966d2de}
Return the sign of x.

\begin{DoxyReturn}{Returns}
1 if the corresponding element of x is greater than zero; 0 if the corresponding element of X equals zero; -\/1 if the corresponding element of X is less than zero 
\end{DoxyReturn}


References Pecos\+::sgn().



Referenced by Pecos\+::sgn().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!reverse@{reverse}}
\index{reverse@{reverse}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{reverse(\+Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&v)}{reverse(Teuchos::SerialDenseVector< O, T > &v)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::reverse (
\begin{DoxyParamCaption}
\item[{Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ \&}]{v}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_aead46682ff85de914142151a1c132a54}


Reverse the contents of a vector. 

Useful for changing an ordered array to/from ascending/descending order 

References Pecos\+::range(), Pecos\+::reshape(), Pecos\+::resize(), and Pecos\+::reverse().



Referenced by Pecos\+::reverse().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!convert@{convert}}
\index{convert@{convert}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{convert(\+T a[], int m, int n, std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&v)}{convert(T a[], int m, int n, std::vector< Teuchos::SerialDenseVector< O, T > > &v)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::convert (
\begin{DoxyParamCaption}
\item[{T}]{a\mbox{[}$\,$\mbox{]}, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&}]{v}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_ac949ae4248474a32c99b3463f24b0b7a}
Convert a static array to a \char`\"{}\+Vector.\+hpp\char`\"{} of vectors. 
\begin{DoxyParams}{Parameters}
{\em a} & array to be converted \\
\hline
{\em n} & the number of vectors \\
\hline
{\em m} & the size of each \char`\"{}\+Vector.\+hpp\char`\"{} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
v the \char`\"{}\+Vector.\+hpp\char`\"{} of vectors 
\end{DoxyReturn}


References Pecos\+::convert().



Referenced by Pecos\+::convert().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!convert@{convert}}
\index{convert@{convert}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{convert(\+T a[], int m, int n, std\+::set$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&s)}{convert(T a[], int m, int n, std::set< Teuchos::SerialDenseVector< O, T > > &s)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::convert (
\begin{DoxyParamCaption}
\item[{T}]{a\mbox{[}$\,$\mbox{]}, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{std\+::set$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&}]{s}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a87a9e0561e70289efe24bf0fbbbddcec}
Convert a static array to a weakly ordered multiset of vectors. Set allows for multiple keys with the same value. 
\begin{DoxyParams}{Parameters}
{\em a} & array to be converted \\
\hline
{\em n} & the number of vectors \\
\hline
{\em m} & the size of each \char`\"{}\+Vector.\+hpp\char`\"{} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
s the set 
\end{DoxyReturn}


References Pecos\+::convert().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!convert@{convert}}
\index{convert@{convert}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{convert(const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&\+V, Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&\+M)}{convert(const std::vector< Teuchos::SerialDenseVector< O, T > > &V, Teuchos::SerialDenseMatrix< O, T > &M)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::convert (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ Teuchos\+::\+Serial\+Dense\+Vector$<$ O, T $>$ $>$ \&}]{V, }
\item[{Teuchos\+::\+Serial\+Dense\+Matrix$<$ O, T $>$ \&}]{M}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_a9534dfa37a95edeef7cca8d3e0aa0f5d}


Convert a std\+::vector of vectors to a matrix. 

Each element of the std\+::vector becomes a column of the matrix 

References Pecos\+::convert().

\index{Math\+Tools.\+hpp@{Math\+Tools.\+hpp}!accumulate@{accumulate}}
\index{accumulate@{accumulate}!Math\+Tools.\+hpp@{Math\+Tools.\+hpp}}
\subsubsection[{\texorpdfstring{accumulate(const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&vectors, std\+::vector$<$ T $>$ \&result, Operator op)}{accumulate(const std::vector< std::vector< T > > &vectors, std::vector< T > &result, Operator op)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pecos\+::accumulate (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{vectors, }
\item[{std\+::vector$<$ T $>$ \&}]{result, }
\item[{Operator}]{op}
\end{DoxyParamCaption}
)}\label{MathTools_8hpp_file_ab2eea3aedce948033aa263ee5811afc9}
Add a set of vectors together. 
\begin{DoxyParams}{Parameters}
{\em vectors} & set of vectors to be added \\
\hline
{\em result} & the accumualted values \\
\hline
\end{DoxyParams}


References Pecos\+::accumulate().



Referenced by Pecos\+::accumulate().

