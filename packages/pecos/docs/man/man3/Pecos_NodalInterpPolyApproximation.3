.TH "NodalInterpPolyApproximation" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NodalInterpPolyApproximation \- Derived approximation class for nodal interpolation polynomials (global approximation interpolating function values and potentially gradients at collocation points)\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBInterpPolyApproximation\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNodalInterpPolyApproximation\fP (const \fBSharedBasisApproxData\fP &shared_data)"
.br
.RI "\fIdefault constructor \fP"
.ti -1c
.RI "\fB~NodalInterpPolyApproximation\fP ()"
.br
.RI "\fIdestructor \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBallocate_arrays\fP ()"
.br
.RI "\fIsize expansionType{1,2}Coeffs and expansionType1CoeffGrads \fP"
.ti -1c
.RI "void \fBcompute_coefficients\fP (size_t index=_NPOS)"
.br
.RI "\fIcalculate the approximation coefficients using a set of surrogate data \fP"
.ti -1c
.RI "void \fBincrement_coefficients\fP (size_t index=_NPOS)"
.br
.RI "\fIupdate the coefficients for the expansion of interpolation polynomials: increment expansion{Type1Coeffs,Type2Coeffs,Type1CoeffGrads} \fP"
.ti -1c
.RI "void \fBdecrement_coefficients\fP (bool save_data)"
.br
.RI "\fIrestore the coefficients to their previous state prior to last increment: decrement expansion{Type1Coeffs,Type2Coeffs,Type1CoeffGrads} \fP"
.ti -1c
.RI "void \fBpush_coefficients\fP ()"
.br
.RI "\fIrestore the coefficients to a previously incremented state as identified by the current increment to the Smolyak multi index: push expansion{Type1Coeffs,Type2Coeffs,Type1CoeffGrads} \fP"
.ti -1c
.RI "void \fBfinalize_coefficients\fP ()"
.br
.RI "\fIfinalize the coefficients by applying all previously evaluated increments: finalize expansion{Type1Coeffs,Type2Coeffs,Type1CoeffGrads} \fP"
.ti -1c
.RI "void \fBstore_coefficients\fP (size_t index=_NPOS)"
.br
.RI "\fIstore current state within storedExpType{1Coeffs,2Coeffs,1CoeffGrads} \fP"
.ti -1c
.RI "void \fBrestore_coefficients\fP (size_t index=_NPOS)"
.br
.RI "\fIrestore previous state from storedExpType{1Coeffs,2Coeffs,1CoeffGrads} \fP"
.ti -1c
.RI "void \fBswap_coefficients\fP (size_t index)"
.br
.RI "\fIswap storedExpType{1Coeffs,2Coeffs,1CoeffGrads}[index] with active current data \fP"
.ti -1c
.RI "void \fBremove_stored_coefficients\fP (size_t index=_NPOS)"
.br
.RI "\fIremove a redundant entry from storedExpType{1Coeffs,2Coeffs,1CoeffGrads} prior to combine_coefficients (default is pop_back) \fP"
.ti -1c
.RI "void \fBclear_stored\fP ()"
.br
.RI "\fIclear storedExpType{1Coeffs,2Coeffs,1CoeffGrads} \fP"
.ti -1c
.RI "void \fBcombine_coefficients\fP (size_t swap_index)"
.br
.RI "\fIaugment current interpolant using storedExpType{1Coeffs,2Coeffs,1CoeffGrads}[index] \fP"
.ti -1c
.RI "void \fBintegrate_response_moments\fP (size_t num_moments)"
.br
.RI "\fIcompute moments of response using numerical integration \fP"
.ti -1c
.RI "void \fBintegrate_expansion_moments\fP (size_t num_moments)"
.br
.RI "\fIcompute moments of expansion using numerical integration \fP"
.ti -1c
.RI "Real \fBvalue\fP (const RealVector &x)"
.br
.RI "\fIretrieve the approximate function value for a given parameter vector \fP"
.ti -1c
.RI "const RealVector & \fBgradient_basis_variables\fP (const RealVector &x)"
.br
.RI "\fIretrieve the gradient for a response expansion with respect to all variables included in the polynomial bases using the given parameter vector and default DVV \fP"
.ti -1c
.RI "const RealVector & \fBgradient_basis_variables\fP (const RealVector &x, const SizetArray &dvv)"
.br
.ti -1c
.RI "const RealVector & \fBgradient_nonbasis_variables\fP (const RealVector &x)"
.br
.RI "\fIretrieve the gradient for a response expansion with respect to all variables not included in the polynomial bases (nonprobabilistic variables such as design or epistemic when not in 'all' mode) using the given parameter vector and default DVV \fP"
.ti -1c
.RI "const RealSymMatrix & \fBhessian_basis_variables\fP (const RealVector &x)"
.br
.RI "\fIretrieve the Hessian of the response expansion with respect to all variables included in the polynomial basis (e\&.g\&., probabilistic variables) for a given parameter vector \fP"
.ti -1c
.RI "Real \fBstored_value\fP (const RealVector &x, size_t index)"
.br
.RI "\fIretrieve the response value for a stored expansion using the given parameter vector \fP"
.ti -1c
.RI "const RealVector & \fBstored_gradient_basis_variables\fP (const RealVector &x, size_t index)"
.br
.RI "\fIretrieve the response gradient for a stored expansion with respect to all variables included in the polynomial bases; evaluate for the given parameter vector\&. \fP"
.ti -1c
.RI "const RealVector & \fBstored_gradient_nonbasis_variables\fP (const RealVector &x, size_t index)"
.br
.RI "\fIretrieve the response gradient for a stored expansion with respect to all variables not included in the polynomial bases; evaluate for the given parameter vector\&. \fP"
.ti -1c
.RI "Real \fBmean\fP ()"
.br
.ti -1c
.RI "Real \fBmean\fP (const RealVector &x)"
.br
.ti -1c
.RI "const RealVector & \fBmean_gradient\fP ()"
.br
.ti -1c
.RI "const RealVector & \fBmean_gradient\fP (const RealVector &x, const SizetArray &dvv)"
.br
.ti -1c
.RI "Real \fBvariance\fP ()"
.br
.ti -1c
.RI "Real \fBvariance\fP (const RealVector &x)"
.br
.ti -1c
.RI "const RealVector & \fBvariance_gradient\fP ()"
.br
.ti -1c
.RI "const RealVector & \fBvariance_gradient\fP (const RealVector &x, const SizetArray &dvv)"
.br
.ti -1c
.RI "Real \fBcovariance\fP (\fBPolynomialApproximation\fP *poly_approx_2)"
.br
.ti -1c
.RI "Real \fBcovariance\fP (const RealVector &x, \fBPolynomialApproximation\fP *poly_approx_2)"
.br
.ti -1c
.RI "void \fBcompute_total_sobol_indices\fP ()"
.br
.ti -1c
.RI "void \fBcompute_partial_variance\fP (const BitArray &set_value)"
.br
.ti -1c
.RI "RealVector \fBapproximation_coefficients\fP (bool normalized) const "
.br
.RI "\fIreturn the coefficient array computed by \fBcompute_coefficients()\fP \fP"
.ti -1c
.RI "void \fBapproximation_coefficients\fP (const RealVector &approx_coeffs, bool normalized)"
.br
.RI "\fIset the coefficient array from external sources, rather than computing with \fBcompute_coefficients()\fP \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdate_expansion_coefficients\fP ()"
.br
.RI "\fIupdate expansionType{1Coeffs,2Coeffs,1CoeffGrads} following changes to surrData \fP"
.ti -1c
.RI "Real \fBtensor_product_mean\fP (const RealVector &x, const UShortArray &lev_index, const UShort2DArray &key, const SizetArray &colloc_index)"
.br
.RI "\fIcompute the mean of a tensor interpolant on a tensor grid; contributes to mean(x) \fP"
.ti -1c
.RI "const RealVector & \fBtensor_product_mean_gradient\fP (const RealVector &x, const UShortArray &lev_index, const UShort2DArray &key, const SizetArray &colloc_index, const SizetArray &dvv)"
.br
.RI "\fIcompute the gradient of the mean of a tensor interpolant on a tensor grid; contributes to mean_gradient(x) \fP"
.ti -1c
.RI "Real \fBtensor_product_covariance\fP (const RealVector &x, const UShortArray &lev_index, const UShort2DArray &key, const SizetArray &colloc_index, \fBNodalInterpPolyApproximation\fP *nip_approx_2)"
.br
.RI "\fIcompute the covariance of two tensor interpolants on the same tensor grid using an interpolation of products or product of interpolants approach; contributes to covariance(x, poly_approx_2) \fP"
.ti -1c
.RI "Real \fBtensor_product_covariance\fP (const RealVector &x, const UShortArray &lev_index_1, const UShort2DArray &key_1, const SizetArray &colloc_index_1, const UShortArray &lev_index_2, const UShort2DArray &key_2, const SizetArray &colloc_index_2, \fBNodalInterpPolyApproximation\fP *nip_approx_2)"
.br
.RI "\fIcompute the covariance of two tensor interpolants on different tensor grids using a product of interpolants approach; contributes to covariance(x, poly_approx_2) \fP"
.ti -1c
.RI "const RealVector & \fBtensor_product_variance_gradient\fP (const RealVector &x, const UShortArray &lev_index, const UShort2DArray &key, const SizetArray &colloc_index, const SizetArray &dvv)"
.br
.RI "\fIcompute the gradient of the variance of a tensor interpolant on a tensor grid using an interpolation of products or product of interpolants approach; contributes to variance_gradient(x) \fP"
.ti -1c
.RI "Real \fBvalue\fP (const RealVector &x, const RealVectorArray &t1_coeffs, const RealMatrixArray &t2_coeffs, const UShort3DArray &colloc_key, const SizetList &subset_indices)"
.br
.RI "\fIcompute value of reduced-dimension interpolant \fP"
.ti -1c
.RI "const RealVector & \fBgradient_basis_variables\fP (const RealVector &x, const RealVectorArray &t1_coeffs, const RealMatrixArray &t2_coeffs, const UShort3DArray &colloc_key, const SizetList &subset_indices)"
.br
.RI "\fIcompute gradient of reduced-dimension interpolant with respect to basis variables \fP"
.ti -1c
.RI "Real \fBexpectation\fP (const RealVector &t1_coeffs, const RealMatrix &t2_coeffs)"
.br
.RI "\fIcompute the expected value of the interpolant given by t{1,2}_coeffs using weights from the \fBCombinedSparseGridDriver\fP \fP"
.ti -1c
.RI "Real \fBexpectation\fP (const RealVector &t1_coeffs, const RealVector &t1_wts, const RealMatrix &t2_coeffs, const RealMatrix &t2_wts)"
.br
.RI "\fIcompute the expected value of the interpolant given by t{1,2}_coeffs using t{1,2}_wts \fP"
.ti -1c
.RI "void \fBreinterpolated_level\fP (const UShortArray &lev_index)"
.br
.RI "\fIcomputes higher-order grid for tensor reinterpolation of the covariance fn for non-integrated dimensions in all_variables mode \fP"
.ti -1c
.RI "Real \fBmember_integral\fP (const BitArray &member_bits, Real \fBmean\fP)"
.br
.RI "\fIcompute integral for total Sobol' index for variables in a set \fP"
.ti -1c
.RI "void \fBmember_coefficients_weights\fP (const BitArray &member_bits, const UShortArray &quad_order, const UShortArray &lev_index, const UShort2DArray &colloc_key, const SizetArray &colloc_index, RealVector &member_t1_coeffs, RealVector &member_t1_wts, RealMatrix &member_t2_coeffs, RealMatrix &member_t2_wts, UShort2DArray &member_colloc_key, SizetArray &member_colloc_index)"
.br
.RI "\fIdefines member_coeffs and member_wts for a particular membership set \fP"
.ti -1c
.RI "void \fBupdate_member_key\fP (const UShortArray &data, const SizetList &member_indices, UShortArray &member_map_key, size_t cntr)"
.br
.RI "\fIcreate a unique map key for \fBvalue()\fP and \fBgradient()\fP calculation reuse \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "RealVector \fBexpansionType1Coeffs\fP"
.br
.RI "\fIthe type1 coefficients of the expansion for interpolating values \fP"
.ti -1c
.RI "RealMatrix \fBexpansionType2Coeffs\fP"
.br
.RI "\fIthe type2 coefficients of the expansion for interpolating gradients \fP"
.ti -1c
.RI "RealMatrix \fBexpansionType1CoeffGrads\fP"
.br
.RI "\fIthe gradients of the type1 expansion coefficients \fP"
.ti -1c
.RI "RealVectorArray \fBstoredExpType1Coeffs\fP"
.br
.RI "\fIcopies of expansionType1Coeffs state for subsequent restoration \fP"
.ti -1c
.RI "RealMatrixArray \fBstoredExpType2Coeffs\fP"
.br
.RI "\fIcopies of expansionType2Coeffs state for subsequent restoration \fP"
.ti -1c
.RI "RealMatrixArray \fBstoredExpType1CoeffGrads\fP"
.br
.RI "\fIcopies of expansionType1CoeffGrads state for subsequent restoration \fP"
.ti -1c
.RI "RealVector \fBtpMeanGrad\fP"
.br
.RI "\fIthe gradient of the mean of a tensor-product interpolant; a contributor to meanGradient \fP"
.ti -1c
.RI "RealVector \fBtpVarianceGrad\fP"
.br
.RI "\fIthe gradient of the variance of a tensor-product interpolant; a contributor to varianceGradient \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Derived approximation class for nodal interpolation polynomials (global approximation interpolating function values and potentially gradients at collocation points)\&. 

The \fBNodalInterpPolyApproximation\fP class provides a global polynomial approximation based on either Lagrange or Hermite interpolation polynomials using a nodal basis approach\&. It is used primarily for stochastic collocation approaches to uncertainty quantification\&. 
.SH "Member Function Documentation"
.PP 
.SS "const RealVector & gradient_basis_variables (const RealVector & x, const SizetArray & dvv)\fC [protected]\fP, \fC [virtual]\fP"
Special case used for sparse grid interpolation on variable sub-sets defined from partial integration\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References PolynomialApproximation::approxGradient, CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), SharedNodalInterpPolyApproxData::csg_driver(), PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, NodalInterpPolyApproximation::gradient_nonbasis_variables(), TensorProductDriver::level_index(), BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), and SharedNodalInterpPolyApproxData::tpq_driver()\&.
.SS "Real mean ()\fC [protected]\fP, \fC [virtual]\fP"
In this case, all expansion variables are random variables and the mean of the expansion is simply the sum over i of r_i w_i\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References PolynomialApproximation::computedMean, PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, NodalInterpPolyApproximation::expectation(), SharedPolyApproxData::nonRandomIndices, PolynomialApproximation::numericalMoments, and BasisApproximation::sharedDataRep\&.
.PP
Referenced by NodalInterpPolyApproximation::compute_partial_variance(), NodalInterpPolyApproximation::covariance(), NodalInterpPolyApproximation::mean(), NodalInterpPolyApproximation::member_integral(), NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and NodalInterpPolyApproximation::variance_gradient()\&.
.SS "Real mean (const RealVector & x)\fC [protected]\fP, \fC [virtual]\fP"
In this case, a subset of the expansion variables are random variables and the mean of the expansion involves integration over this subset and evaluation over the subset's complement\&. For the linear sums of tensor interpolants within a sparse interpolant, the expectation can be taken inside the sum and we can simply add up the tensor mean contributions\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), PolynomialApproximation::computedMean, SharedNodalInterpPolyApproxData::csg_driver(), ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, TensorProductDriver::level_index(), SharedPolyApproxData::match_nonrandom_vars(), NodalInterpPolyApproximation::mean(), SharedPolyApproxData::nonRandomIndices, PolynomialApproximation::numericalMoments, BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), NodalInterpPolyApproximation::tensor_product_mean(), SharedNodalInterpPolyApproxData::tpq_driver(), and PolynomialApproximation::xPrevMean\&.
.SS "const RealVector & mean_gradient ()\fC [protected]\fP, \fC [virtual]\fP"
In this function, all expansion variables are random variables and any design/state variables are omitted from the expansion\&. In this case, the derivative of the expectation is the expectation of the derivative\&. The mixed derivative case (some design variables are inserted and some are augmented) requires no special treatment\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References PolynomialApproximation::computedMean, SharedPolyApproxData::driverRep, PolynomialApproximation::expansionCoeffGradFlag, NodalInterpPolyApproximation::expansionType1CoeffGrads, PolynomialApproximation::meanGradient, SharedPolyApproxData::nonRandomIndices, BasisApproximation::sharedDataRep, and IntegrationDriver::type1_weight_sets()\&.
.PP
Referenced by NodalInterpPolyApproximation::tensor_product_variance_gradient()\&.
.SS "const RealVector & mean_gradient (const RealVector & x, const SizetArray & dvv)\fC [protected]\fP, \fC [virtual]\fP"
In this function, a subset of the expansion variables are random variables and any augmented design/state variables (i\&.e\&., not inserted as random variable distribution parameters) are included in the expansion\&. In this case, the mean of the expansion is the expectation over the random subset and the derivative of the mean is the derivative of the remaining expansion over the non-random subset\&. This function must handle the mixed case, where some design/state variables are augmented (and are part of the expansion: derivatives are evaluated as described above) and some are inserted (derivatives are obtained from expansionType1CoeffGrads)\&. For the linear sums of tensor interpolants within a sparse interpolant, the expectation can be taken inside the sum and we can simply add up the tensor mean gradient contributions\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), PolynomialApproximation::computedMean, NodalInterpPolyApproximation::covariance(), SharedNodalInterpPolyApproxData::csg_driver(), ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, TensorProductDriver::level_index(), SharedPolyApproxData::match_nonrandom_vars(), PolynomialApproximation::meanGradient, SharedPolyApproxData::nonRandomIndices, BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), NodalInterpPolyApproximation::tpMeanGrad, SharedNodalInterpPolyApproxData::tpq_driver(), and PolynomialApproximation::xPrevMeanGrad\&.
.SS "Real variance ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"
In this case, all expansion variables are random variables and the variance of the expansion uses an interpolation of response products\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References NodalInterpPolyApproximation::covariance()\&.
.PP
Referenced by NodalInterpPolyApproximation::compute_partial_variance()\&.
.SS "Real variance (const RealVector & x)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"
In this case, a subset of the expansion variables are random variables and the variance of the expansion involves integration over this subset and evaluation over the subset's complement\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References NodalInterpPolyApproximation::covariance(), and NodalInterpPolyApproximation::expectation()\&.
.SS "const RealVector & variance_gradient ()\fC [protected]\fP, \fC [virtual]\fP"
In this function, all expansion variables are random variables and any design/state variables are omitted from the expansion\&. The mixed derivative case (some design/epistemic variables are inserted and some are augmented) requires no special treatment\&. Since we reinterpolate the central products (INTERPOLATION_OF_PRODUCTS is the only option for the standard expansion mode) such that we retain the linear sums of tensor interpolants within a sparse interpolant, the expectation gradient simply involves a summation over the sparse integration weights\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References PolynomialApproximation::computedVariance, SharedPolyApproxData::driverRep, PolynomialApproximation::expansionCoeffFlag, PolynomialApproximation::expansionCoeffGradFlag, NodalInterpPolyApproximation::expansionType1CoeffGrads, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::mean(), SharedPolyApproxData::nonRandomIndices, BasisApproximation::sharedDataRep, IntegrationDriver::type1_weight_sets(), and PolynomialApproximation::varianceGradient\&.
.SS "const RealVector & variance_gradient (const RealVector & x, const SizetArray & dvv)\fC [protected]\fP, \fC [virtual]\fP"
In this function, a subset of the expansion variables are random variables and any augmented design/state variables (i\&.e\&., not inserted as random variable distribution parameters) are included in the expansion\&. This function must handle the mixed case, where some design/state variables are augmented (and are part of the expansion) and some are inserted (derivatives are obtained from expansionType1CoeffGrads)\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), PolynomialApproximation::computedVariance, SharedNodalInterpPolyApproxData::csg_driver(), ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, NodalInterpPolyApproximation::expectation(), TensorProductDriver::level_index(), SharedPolyApproxData::match_nonrandom_vars(), SharedNodalInterpPolyApproxData::momentInterpType, SharedPolyApproxData::nonRandomIndices, NodalInterpPolyApproximation::reinterpolated_level(), BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), SharedNodalInterpPolyApproxData::tpq_driver(), NodalInterpPolyApproximation::tpVarianceGrad, PolynomialApproximation::varianceGradient, and PolynomialApproximation::xPrevVarGrad\&.
.SS "Real covariance (\fBPolynomialApproximation\fP * poly_approx_2)\fC [protected]\fP, \fC [virtual]\fP"
In this case, all expansion variables are random variables and the variance of the expansion uses an interpolation of central products (INTERPOLATION_OF_PRODUCTS is the only option for the standard expansion mode)\&. Since we reinterpolate the central products such that we retain the linear sums of tensor interpolants within a sparse interpolant, the expectation simply involves a summation over the sparse integration weights\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References SharedPolyApproxData::basisConfigOptions, PolynomialApproximation::computedVariance, SharedPolyApproxData::driverRep, PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, NodalInterpPolyApproximation::mean(), SharedPolyApproxData::nonRandomIndices, PolynomialApproximation::numericalMoments, SharedBasisApproxData::numVars, BasisApproximation::sharedDataRep, IntegrationDriver::type1_weight_sets(), IntegrationDriver::type2_weight_sets(), and BasisConfigOptions::useDerivs\&.
.PP
Referenced by NodalInterpPolyApproximation::mean_gradient(), and NodalInterpPolyApproximation::variance()\&.
.SS "Real covariance (const RealVector & x, \fBPolynomialApproximation\fP * poly_approx_2)\fC [protected]\fP, \fC [virtual]\fP"
In this case, a subset of the expansion variables are random variables and the variance of the expansion involves integration over this subset\&. Three cases are at least partially implemented (type 2 covariance contributions are not currently implemented for PRODUCT_OF_INTERPOLANTS approaches, and \fBvariance_gradient()\fP is not implemented for PRODUCT_OF_INTERPOLANTS_FULL): (1) REINTERPOLATION_OF_PRODUCTS: (R-)^2 is (re)interpolated, allowing sparse grid covariance to use a linear sum of tensor contributions\&. This is most consistent with covariance for the standard variables mode\&. The penalty is that the reinterpolated function is higher order\&. (1) INTERPOLATION_OF_PRODUCTS: (R-)^2 is interpolated, allowing sparse grid covariance to use a linear sum of tensor contributions\&. This is most consistent with covariance for the standard variables mode\&. (2) PRODUCT_OF_INTERPOLANTS_FAST: the covariance of the existing sparse interpolant is computed without reinterpolation, but only the individual covariances from matching tensor grids are included\&. Covariance from mismatched tensor grids is neglected, and the mean reference values are individual tensor means, not the 'total' mean\&. Due to some fortuitous cancellations in the Smolyak construction that have not been fully analyzed, this shortcut/fast approach is often quite accurate\&. (3) PRODUCT_OF_INTERPOLANTS_FULL: the covariance of the existing sparse interpolant is computed without reinterpolation, the sparse covariance among all tensor grid combinations is included, and the total mean is used as the reference value for all products\&. The covariance among mismatched tensor grids requires the evaluation of expectations of mismatched interpolation polynomials (matched order basis polynomials admit a Kronecker delta simplification)\&. This option has been the most accurate in testing but, despite attempts at pre-computation and fast lookup of these products, has been too expensive for large grids\&. 
.PP
Implements \fBPolynomialApproximation\fP\&.
.PP
References CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), PolynomialApproximation::computedVariance, SharedNodalInterpPolyApproxData::csg_driver(), PolynomialApproximation::expansionCoeffFlag, ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, TensorProductDriver::level_index(), SharedPolyApproxData::match_nonrandom_vars(), SharedNodalInterpPolyApproxData::momentInterpType, SharedPolyApproxData::nonRandomIndices, PolynomialApproximation::numericalMoments, NodalInterpPolyApproximation::reinterpolated_level(), BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), NodalInterpPolyApproximation::tensor_product_covariance(), SharedNodalInterpPolyApproxData::tpq_driver(), SharedNodalInterpPolyApproxData::update_nonzero_basis_products(), and PolynomialApproximation::xPrevVar\&.
.SS "void compute_partial_variance (const BitArray & set_value)\fC [protected]\fP, \fC [virtual]\fP"
Computes the variance of component functions\&. Assumes that all subsets of set_value have been computed in advance which will be true so long as the partial_variance is called following appropriate enumeration of set value 
.PP
Reimplemented from \fBInterpPolyApproximation\fP\&.
.PP
References InterpPolyApproximation::compute_partial_variance(), NodalInterpPolyApproximation::mean(), NodalInterpPolyApproximation::member_integral(), SharedBasisApproxData::numVars, InterpPolyApproximation::partialVariance, BasisApproximation::sharedDataRep, SharedPolyApproxData::sobolIndexMap, PolynomialApproximation::totalSobolIndices, and NodalInterpPolyApproximation::variance()\&.
.PP
Referenced by NodalInterpPolyApproximation::integrate_expansion_moments()\&.
.SS "Real tensor_product_mean (const RealVector & x, const UShortArray & lev_index, const UShort2DArray & key, const SizetArray & colloc_index)\fC [private]\fP"

.PP
compute the mean of a tensor interpolant on a tensor grid; contributes to mean(x) Overloaded all_variables version supporting Smolyak sparse grids\&. 
.PP
References SharedNodalInterpPolyApproxData::accumulate_barycentric(), SharedNodalInterpPolyApproxData::accumulate_horners(), BasisPolynomial::barycentric_value_factors(), SharedInterpPolyApproxData::barycentric_value_scaling(), SharedInterpPolyApproxData::barycentricFlag, SharedPolyApproxData::basisConfigOptions, SharedPolyApproxData::driverRep, BasisPolynomial::exact_index(), PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, BasisPolynomial::interpolation_size(), SharedPolyApproxData::nonRandomIndices, SharedBasisApproxData::numVars, SharedInterpPolyApproxData::polynomialBasis, SharedPolyApproxData::randomVarsKey, SharedNodalInterpPolyApproxData::set_new_point(), BasisApproximation::sharedDataRep, NodalInterpPolyApproximation::tensor_product_mean_gradient(), IntegrationDriver::type1_collocation_weights_1d(), BasisPolynomial::type1_value(), IntegrationDriver::type2_collocation_weights_1d(), BasisPolynomial::type2_value(), and BasisConfigOptions::useDerivs\&.
.PP
Referenced by NodalInterpPolyApproximation::mean(), NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and NodalInterpPolyApproximation::update_expansion_coefficients()\&.
.SS "const RealVector & tensor_product_mean_gradient (const RealVector & x, const UShortArray & lev_index, const UShort2DArray & key, const SizetArray & colloc_index, const SizetArray & dvv)\fC [private]\fP"

.PP
compute the gradient of the mean of a tensor interpolant on a tensor grid; contributes to mean_gradient(x) Overloaded all_variables version supporting Smolyak sparse grids\&. 
.PP
References SharedNodalInterpPolyApproxData::accumulate_barycentric_gradient(), SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), BasisPolynomial::barycentric_gradient_factors(), BasisPolynomial::barycentric_value_factors(), SharedInterpPolyApproxData::barycentricFlag, SharedPolyApproxData::basisConfigOptions, SharedPolyApproxData::driverRep, BasisPolynomial::exact_index(), PolynomialApproximation::expansionCoeffFlag, PolynomialApproximation::expansionCoeffGradFlag, NodalInterpPolyApproximation::expansionType1CoeffGrads, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, BasisPolynomial::interpolation_size(), SharedPolyApproxData::nonRandomIndices, SharedBasisApproxData::numVars, SharedInterpPolyApproxData::polynomialBasis, SharedPolyApproxData::randomVarsKey, SharedNodalInterpPolyApproxData::set_new_point(), BasisApproximation::sharedDataRep, NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tpMeanGrad, IntegrationDriver::type1_collocation_weights_1d(), BasisPolynomial::type1_gradient(), BasisPolynomial::type1_value(), IntegrationDriver::type2_collocation_weights_1d(), BasisPolynomial::type2_gradient(), BasisPolynomial::type2_value(), and BasisConfigOptions::useDerivs\&.
.PP
Referenced by NodalInterpPolyApproximation::mean_gradient(), NodalInterpPolyApproximation::tensor_product_mean(), and NodalInterpPolyApproximation::tensor_product_variance_gradient()\&.
.SS "Real tensor_product_covariance (const RealVector & x, const UShortArray & lev_index, const UShort2DArray & key, const SizetArray & colloc_index, \fBNodalInterpPolyApproximation\fP * nip_approx_2)\fC [private]\fP"

.PP
compute the covariance of two tensor interpolants on the same tensor grid using an interpolation of products or product of interpolants approach; contributes to covariance(x, poly_approx_2) Covariance of response functions for a matched tensor product grid\&. Supports all_variables mode and either interpolation of products or product of interpolants formulations\&. For the latter, recursive usage only provides the 'diagonal' contributions from matched tensor products (PRODUCT_OF_INTERPOLANTS_FAST); an exact estimation (PRODUCT_OF_INTERPOLANTS_FULL) requires augmentation with mixed tensor product contributions using the overloaded form of this function\&. 
.PP
References SharedNodalInterpPolyApproxData::accumulate_barycentric(), SharedNodalInterpPolyApproxData::accumulate_horners(), BasisPolynomial::barycentric_value_factors(), SharedInterpPolyApproxData::barycentricFlag, SharedPolyApproxData::basisConfigOptions, SharedPolyApproxData::driverRep, BasisPolynomial::exact_index(), PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, NodalInterpPolyApproximation::gradient_basis_variables(), BasisPolynomial::interpolation_size(), SharedPolyApproxData::match_random_key(), NodalInterpPolyApproximation::mean(), SharedNodalInterpPolyApproxData::momentInterpType, SharedPolyApproxData::nonRandomIndices, SharedBasisApproxData::numVars, SharedInterpPolyApproxData::polynomialBasis, SharedPolyApproxData::randomIndices, SharedPolyApproxData::randomVarsKey, IntegrationDriver::reinterpolated_collocation_key(), IntegrationDriver::reinterpolated_level_index(), IntegrationDriver::reinterpolated_variable_sets(), SharedNodalInterpPolyApproxData::set_new_point(), BasisApproximation::sharedDataRep, NodalInterpPolyApproximation::tensor_product_mean(), IntegrationDriver::type1_collocation_weights_1d(), SharedInterpPolyApproxData::type1_interpolant_value(), BasisPolynomial::type1_value(), SharedInterpPolyApproxData::type1_weight(), IntegrationDriver::type2_collocation_weights_1d(), BasisPolynomial::type2_value(), BasisConfigOptions::useDerivs, and NodalInterpPolyApproximation::value()\&.
.PP
Referenced by NodalInterpPolyApproximation::covariance(), and NodalInterpPolyApproximation::tensor_product_mean_gradient()\&.
.SS "Real tensor_product_covariance (const RealVector & x, const UShortArray & lev_index_1, const UShort2DArray & key_1, const SizetArray & colloc_index_1, const UShortArray & lev_index_2, const UShort2DArray & key_2, const SizetArray & colloc_index_2, \fBNodalInterpPolyApproximation\fP * nip_approx_2)\fC [private]\fP"

.PP
compute the covariance of two tensor interpolants on different tensor grids using a product of interpolants approach; contributes to covariance(x, poly_approx_2) Covariance of response functions for differing tensor products using a PRODUCT_OF_INTERPOLANTS_FULL approach\&. Needed for sparse interpolants in all_variables mode\&. 
.PP
References SharedNodalInterpPolyApproxData::basis_product(), PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, NodalInterpPolyApproximation::mean(), SharedNodalInterpPolyApproxData::momentInterpType, SharedPolyApproxData::nonRandomIndices, BasisApproximation::sharedDataRep, NodalInterpPolyApproximation::tensor_product_variance_gradient(), and SharedInterpPolyApproxData::type1_interpolant_value()\&.
.SS "const RealVector & tensor_product_variance_gradient (const RealVector & x, const UShortArray & lev_index, const UShort2DArray & key, const SizetArray & colloc_index, const SizetArray & dvv)\fC [private]\fP"

.PP
compute the gradient of the variance of a tensor interpolant on a tensor grid using an interpolation of products or product of interpolants approach; contributes to variance_gradient(x) Overloaded all_variables version supporting interpolation of products or product of interpolants approaches\&. 
.PP
References SharedNodalInterpPolyApproxData::accumulate_barycentric_gradient(), SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), BasisPolynomial::barycentric_gradient_factors(), BasisPolynomial::barycentric_value_factors(), SharedInterpPolyApproxData::barycentricFlag, SharedPolyApproxData::basisConfigOptions, SharedPolyApproxData::driverRep, BasisPolynomial::exact_index(), PolynomialApproximation::expansionCoeffFlag, PolynomialApproximation::expansionCoeffGradFlag, NodalInterpPolyApproximation::expansionType1CoeffGrads, NodalInterpPolyApproximation::expansionType1Coeffs, NodalInterpPolyApproximation::expansionType2Coeffs, NodalInterpPolyApproximation::gradient_basis_variables(), NodalInterpPolyApproximation::gradient_nonbasis_variables(), BasisPolynomial::interpolation_size(), SharedPolyApproxData::match_random_key(), NodalInterpPolyApproximation::mean(), NodalInterpPolyApproximation::mean_gradient(), SharedNodalInterpPolyApproxData::momentInterpType, SharedPolyApproxData::nonRandomIndices, SharedBasisApproxData::numVars, SharedInterpPolyApproxData::polynomialBasis, SharedPolyApproxData::randomIndices, SharedPolyApproxData::randomVarsKey, IntegrationDriver::reinterpolated_collocation_key(), IntegrationDriver::reinterpolated_level_index(), IntegrationDriver::reinterpolated_variable_sets(), SharedNodalInterpPolyApproxData::set_new_point(), BasisApproximation::sharedDataRep, NodalInterpPolyApproximation::tensor_product_mean(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), NodalInterpPolyApproximation::tpVarianceGrad, IntegrationDriver::type1_collocation_weights_1d(), BasisPolynomial::type1_gradient(), SharedInterpPolyApproxData::type1_interpolant_gradient(), SharedInterpPolyApproxData::type1_interpolant_value(), BasisPolynomial::type1_value(), SharedInterpPolyApproxData::type1_weight(), IntegrationDriver::type2_collocation_weights_1d(), BasisPolynomial::type2_gradient(), BasisPolynomial::type2_value(), BasisConfigOptions::useDerivs, and NodalInterpPolyApproximation::value()\&.
.PP
Referenced by NodalInterpPolyApproximation::tensor_product_covariance(), and NodalInterpPolyApproximation::variance_gradient()\&.
.SS "Real value (const RealVector & x, const RealVectorArray & t1_coeffs, const RealMatrixArray & t2_coeffs, const UShort3DArray & colloc_key, const SizetList & subset_indices)\fC [private]\fP"

.PP
compute value of reduced-dimension interpolant Special case used for sparse grid interpolation on variable sub-sets defined from partial integration\&. 
.PP
References SharedNodalInterpPolyApproxData::csg_driver(), PolynomialApproximation::expansionCoeffFlag, NodalInterpPolyApproximation::gradient_basis_variables(), BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), and CombinedSparseGridDriver::smolyak_multi_index()\&.
.SS "void reinterpolated_level (const UShortArray & lev_index)\fC [private]\fP"

.PP
computes higher-order grid for tensor reinterpolation of the covariance fn for non-integrated dimensions in all_variables mode Computes the specifics of a higher order grid for reinterpolating covariance over dimensions that will not be integrated\&. 
.PP
References SharedPolyApproxData::driverRep, NodalInterpPolyApproximation::integrate_response_moments(), SharedPolyApproxData::nonRandomIndices, IntegrationDriver::reinterpolated_level_index(), IntegrationDriver::reinterpolated_tensor_grid(), and BasisApproximation::sharedDataRep\&.
.PP
Referenced by NodalInterpPolyApproximation::covariance(), NodalInterpPolyApproximation::expectation(), and NodalInterpPolyApproximation::variance_gradient()\&.
.SS "Real member_integral (const BitArray & member_bits, Real mean)\fC [private]\fP"

.PP
compute integral for total Sobol' index for variables in a set Forms a new interpolant h over member variables after integrating out the non-member variables\&. Then finds the variance by integrating (h-mean)^2 over the member variables, where the mean can be zero for non-central/raw moment cases\&. 
.PP
References SharedPolyApproxData::basisConfigOptions, CombinedSparseGridDriver::collocation_indices(), TensorProductDriver::collocation_key(), CombinedSparseGridDriver::collocation_key(), SharedNodalInterpPolyApproxData::csg_driver(), ExpansionConfigOptions::expCoeffsSolnApproach, SharedPolyApproxData::expConfigOptions, NodalInterpPolyApproximation::gradient_basis_variables(), TensorProductDriver::level_index(), SparseGridDriver::level_to_order(), NodalInterpPolyApproximation::mean(), NodalInterpPolyApproximation::member_coefficients_weights(), SharedBasisApproxData::numVars, TensorProductDriver::quadrature_order(), BasisApproximation::sharedDataRep, CombinedSparseGridDriver::smolyak_coefficients(), CombinedSparseGridDriver::smolyak_multi_index(), PolynomialApproximation::surrData, SharedNodalInterpPolyApproxData::tpq_driver(), NodalInterpPolyApproximation::update_member_key(), BasisConfigOptions::useDerivs, and NodalInterpPolyApproximation::value()\&.
.PP
Referenced by NodalInterpPolyApproximation::compute_partial_variance()\&.
.SH "Member Data Documentation"
.PP 
.SS "RealMatrix expansionType1CoeffGrads\fC [private]\fP"

.PP
the gradients of the type1 expansion coefficients may be interpreted as either the gradients of the expansion coefficients or the coefficients of expansions for the response gradients\&. This array is used when sensitivities of moments are needed with respect to variables that do not appear in the expansion (e\&.g\&., with respect to design variables for an expansion only over the random variables)\&. 
.PP
Referenced by NodalInterpPolyApproximation::allocate_arrays(), NodalInterpPolyApproximation::combine_coefficients(), NodalInterpPolyApproximation::compute_coefficients(), NodalInterpPolyApproximation::decrement_coefficients(), NodalInterpPolyApproximation::gradient_nonbasis_variables(), NodalInterpPolyApproximation::mean_gradient(), NodalInterpPolyApproximation::restore_coefficients(), NodalInterpPolyApproximation::store_coefficients(), NodalInterpPolyApproximation::swap_coefficients(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), NodalInterpPolyApproximation::update_expansion_coefficients(), and NodalInterpPolyApproximation::variance_gradient()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
