.TH "LinearAlgebra.hpp" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LinearAlgebra.hpp \- Functions used to solve systems of linear equations\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename O , typename T > void \fBreshape\fP (Teuchos::SerialDenseMatrix< O, T > &matrix, O M, O N)"
.br
.RI "\fIReshape a matrix only if the sizes of the matrices differ\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBresize\fP (Teuchos::SerialDenseVector< O, T > &v, O n)"
.br
.RI "\fIReshape a vector only if the sizes of the vectors differ\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBfill_column\fP (int col_number, const Teuchos::SerialDenseMatrix< O, T > &source, Teuchos::SerialDenseMatrix< O, T > &target)"
.br
.RI "\fIFill a column of a matrix with the contents of a flattened matrix\&. The matrix is flattened so that one column proceeds the next\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBappend_column\fP (const Teuchos::SerialDenseVector< O, T > &vector, Teuchos::SerialDenseMatrix< O, T > &matrix)"
.br
.RI "\fIAppend a column vector to a matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBdelete_column\fP (O col_num, Teuchos::SerialDenseMatrix< O, T > &matrix, bool resize=true)"
.br
.RI "\fIDelete a column from a matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBappend_row\fP (const Teuchos::SerialDenseVector< O, T > &vector, Teuchos::SerialDenseMatrix< O, T > &matrix)"
.br
.RI "\fIAppend a row vector to a matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBdeleteRow\fP (O row_num, Teuchos::SerialDenseMatrix< O, T > &matrix, bool resize=true)"
.br
.ti -1c
.RI "template<typename O , typename T > void \fBrow_append\fP (const Teuchos::SerialDenseMatrix< O, T > &source, Teuchos::SerialDenseMatrix< O, T > &target)"
.br
.RI "\fIAppend a matrix to the bottom of another matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBcolumn_append\fP (const Teuchos::SerialDenseMatrix< O, T > &source, Teuchos::SerialDenseMatrix< O, T > &target)"
.br
.RI "\fIAppend a matrix to the right hand side of another matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBfill_row\fP (int row_number, const Teuchos::SerialDenseMatrix< O, T > &source, Teuchos::SerialDenseMatrix< O, T > &target)"
.br
.RI "\fIFill a row of a matrix with the contents of a flattened matrix\&. The matrix is flattened so that one column proceeds the next\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBfill_column\fP (int col_number, const T *source, Teuchos::SerialDenseMatrix< O, T > &target)"
.br
.RI "\fIFill a column of a matrix with the contents of an array\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBtranspose\fP (Teuchos::SerialDenseMatrix< O, T > &matrix, Teuchos::SerialDenseMatrix< O, T > &matrix_transpose)"
.br
.RI "\fIReturn the transpose of a matrix\&. \fP"
.ti -1c
.RI "template<typename O , typename T > bool \fBweakScalarVectorLessThan\fP (const Teuchos::SerialDenseVector< O, T > &v1, const Teuchos::SerialDenseVector< O, T > &v2)"
.br
.ti -1c
.RI "template<typename O , typename T > void \fBpermute_matrix_rows\fP (Teuchos::SerialDenseMatrix< O, T > &A, IntVector &P)"
.br
.ti -1c
.RI "template<typename O , typename T > void \fBpermute_matrix_columns\fP (Teuchos::SerialDenseMatrix< O, T > &A, IntVector &P)"
.br
.ti -1c
.RI "template<typename O , typename T > T \fBtrace\fP (Teuchos::SerialDenseMatrix< O, T > &A)"
.br
.ti -1c
.RI "int \fBcholesky\fP (RealMatrix &A, RealMatrix &result, Teuchos::EUplo uplo, bool for_lapack)"
.br
.RI "\fIcomputes the Cholesky factorization of a real symmetric positive definite matrix A\&. \fP"
.ti -1c
.RI "int \fBsolve_using_cholesky_factor\fP (RealMatrix &L, RealMatrix &B, RealMatrix &result, Teuchos::EUplo uplo)"
.br
.RI "\fISolves a system of linear equations A*X = B with a symmetric positive definite matrix A using a precomputed Cholesky factorization\&. \fP"
.ti -1c
.RI "int \fBcholesky_solve\fP (RealMatrix &A, RealMatrix &B, RealMatrix &result, Real &rcond)"
.br
.RI "\fISolves a system of linear equations A*X = B with a symmetric positive definite matrix A using the Cholesky factorization\&. The cholesky factorization is computed internally\&. \fP"
.ti -1c
.RI "void \fBqr_solve\fP (RealMatrix &A, RealMatrix &B, RealMatrix &result, Teuchos::ETransp trans=Teuchos::NO_TRANS)"
.br
.RI "\fISolves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A\&. It is assumed that A has full rank\&. \fP"
.ti -1c
.RI "void \fBsvd_solve\fP (RealMatrix &A, RealMatrix &B, RealMatrix &result_0, RealVector &result_1, int &rank, Real rcond=\-1)"
.br
.RI "\fICompute the minimum-norm solution to a real linear least squares problem: minimize 2-norm(| b - A*x |) using the singular value decomposition (SVD) of A\&. A is an M-by-N matrix which may be rank-deficient\&. \fP"
.ti -1c
.RI "void \fBsubstitution_solve\fP (RealMatrix &A, RealMatrix &B, RealMatrix &result, Teuchos::ETransp trans=Teuchos::NO_TRANS, Teuchos::EUplo uplo=Teuchos::UPPER_TRI, Teuchos::EDiag diag=Teuchos::NON_UNIT_DIAG)"
.br
.RI "\fISolves a triangular system\&. \fP"
.ti -1c
.RI "int \fBqr_factorization_update_insert_column\fP (RealMatrix &Q, RealMatrix &R, RealMatrix &col, int iter)"
.br
.RI "\fIReturns the QR factorization of [A a] given a qr factorization of A\&. \fP"
.ti -1c
.RI "int \fBcholesky_factorization_update_insert_column\fP (RealMatrix &A, RealMatrix &U, RealMatrix &col, int iter, Real delta=0)"
.br
.RI "\fIReturn the cholesky factorization of a positive definite grammian matrix [A a]'*[A a] given a cholesky factorization of A'*A\&. \fP"
.ti -1c
.RI "void \fBgivens_rotation\fP (RealVector &x, RealVector &x_rot, RealMatrix &givensMatrix)"
.br
.RI "\fICompute the givens rotation of a (2x1) vector x and also returned the rotated vector\&. \fP"
.ti -1c
.RI "void \fBcholesky_factorization_update_delete_column\fP (RealMatrix &U, int col_index, int N)"
.br
.RI "\fIUpdate the cholesky factorization of a positive definite grammian matrix A'A when a column is deleted from A\&. \fP"
.ti -1c
.RI "int \fBconjugate_gradients_solve\fP (RealMatrix &A, RealVector &b, RealVector &x, Real &relative_residual_norm, Real cg_tol, int max_iter, int verbosity)"
.br
.ti -1c
.RI "void \fBequality_constrained_least_squares_solve\fP (RealMatrix &A, RealVector &b, RealMatrix &C, RealVector &d, RealMatrix &x, int verbosity=0)"
.br
.RI "\fISolve the linear equality-constrained least squares (LSE) problem: \fP"
.ti -1c
.RI "void \fBcholesky_inverse\fP (RealMatrix &L, RealMatrix &result, Teuchos::EUplo uplo)"
.br
.RI "\fIComputes the inverse of a real symmetric positive definite matrix A using the Cholesky factorization A = L*L**T or A = U**T*U\&. \fP"
.ti -1c
.RI "void \fBpivoted_qr_factorization\fP (RealMatrix &A, RealMatrix &Q, RealMatrix &R, IntVector &p)"
.br
.ti -1c
.RI "void \fBtruncated_pivoted_lu_factorization\fP (RealMatrix &A, RealMatrix &result_0, RealMatrix &result_1, IntVector &values_0, int max_iters, int num_initial_rows)"
.br
.RI "\fICompute an LU factorization with parital row pivoting of the m-by-n matrix A\&. The factorization has the form A = P * L * U where P is the permutation matrix, L is lower triangular with unit diagonal elements and U is upper triangular\&. \fP"
.ti -1c
.RI "template<typename O , typename T > void \fBeye\fP (int N, Teuchos::SerialDenseMatrix< O, T > &result)"
.br
.ti -1c
.RI "template<typename O , typename T > void \fBunit_vector\fP (int n, int k, Teuchos::SerialDenseVector< O, T > &result)"
.br
.ti -1c
.RI "void \fBlu_inverse\fP (RealMatrix &L, RealMatrix &U, IntVector &p, RealMatrix &LU_inv)"
.br
.ti -1c
.RI "void \fBlu_solve\fP (RealMatrix &A, RealMatrix &B, RealMatrix &result, bool copy, Teuchos::ETransp trans)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions used to solve systems of linear equations\&. 


.PP
\fBAuthor:\fP
.RS 4
John D\&. Jakeman 
.RE
.PP
\fBDate:\fP
.RS 4
2 January 2012 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void Pecos::fill_column (int col_number, const T * source, Teuchos::SerialDenseMatrix< O, T > & target)"

.PP
Fill a column of a matrix with the contents of an array\&. The user must ensure that the length of source is consistent with the target\&. This cannot be used to store a flattened matrix using source\&.values() if source is a sub view\&. 
.PP
References Pecos::fill_column()\&.
.SS "void Pecos::transpose (Teuchos::SerialDenseMatrix< O, T > & matrix, Teuchos::SerialDenseMatrix< O, T > & matrix_transpose)"

.PP
Return the transpose of a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fImatrix\fP (input) the original matrix
.br
\fImatrix_transpose\fP (output) the transpose of the original matrix 
.RE
.PP

.PP
References Pecos::transpose()\&.
.PP
Referenced by Pecos::transpose()\&.
.SS "int cholesky (RealMatrix & A, RealMatrix & result, Teuchos::EUplo uplo, bool for_lapack)"

.PP
computes the Cholesky factorization of a real symmetric positive definite matrix A\&. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP (input) DOUBLE PRECISION positive-definite matrix, dimension (N,N)
.br
\fIfor_lapack\fP flag specifying whether the cholesky factor is to be used for a lapack function\&. If true then if A = L * L**T the upper part is not referenced\&. If false the upper part is filled in with zeros\&. Similarly for A = U**T * U 
.RE
.PP

.SS "int solve_using_cholesky_factor (RealMatrix & L, RealMatrix & B, RealMatrix & result, Teuchos::EUplo uplo)"

.PP
Solves a system of linear equations A*X = B with a symmetric positive definite matrix A using a precomputed Cholesky factorization\&. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X\&. 
.SS "int cholesky_solve (RealMatrix & A, RealMatrix & B, RealMatrix & result, Real & rcond)"

.PP
Solves a system of linear equations A*X = B with a symmetric positive definite matrix A using the Cholesky factorization\&. The cholesky factorization is computed internally\&. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X\&.
.PP
\fBParameters:\fP
.RS 4
\fIrcond\fP (INPUT/OUTPUT) if rcond < 0 compute the reciprocal of the condition number of A and store the result in rcond on output\&. if rcond > 0 rcond is not computed\&. 
.RE
.PP

.SS "void qr_solve (RealMatrix & A, RealMatrix & B, RealMatrix & result, Teuchos::ETransp trans = \fCTeuchos::NO_TRANS\fP)"

.PP
Solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A\&. It is assumed that A has full rank\&. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X\&.
.PP
\fBTodo\fP
.RS 4
at the moment A cannot be rank-defficient\&. implement using dgelsy\&. 
.RE
.PP

.SS "void svd_solve (RealMatrix & A, RealMatrix & B, RealMatrix & result_0, RealVector & result_1, int & rank, Real rcond = \fC\-1\fP)"

.PP
Compute the minimum-norm solution to a real linear least squares problem: minimize 2-norm(| b - A*x |) using the singular value decomposition (SVD) of A\&. A is an M-by-N matrix which may be rank-deficient\&. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X\&.
.PP
The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP (input) DOUBLE PRECISION matrix, dimension (M,N) On entry, the M-by-N matrix A\&.
.br
\fIB\fP (input) DOUBLE PRECISION matrix, dimension (M,NRHS) On entry, the M-by-NRHS right hand side matrix B\&.
.br
\fIresult_1\fP (output) DOUBLE PRECISION matrix, dimension (min(M,N)) The singular values of A in decreasing order\&. The condition number of A in the 2-norm = S(1)/S(min(m,n))\&.
.br
\fIRCOND\fP (input) DOUBLE PRECISION RCOND is used to determine the effective rank of A\&. Singular values S(i) <= RCOND*S(1) are treated as zero\&. If RCOND < 0, machine precision is used instead\&.
.br
\fIRANK\fP (output) INTEGER The effective rank of A, i\&.e\&., the number of singular values which are greater than RCOND*S(1)\&.
.br
\fIresult_0\fP (output) DOUBLE PRECISION matrix, dimension (M,NRHS) On exit, X is the N-by-NRHS solution matrix\&. If m >= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements n+1:m in that column\&.
.RE
.PP
\fBTodo\fP
.RS 4
implement dgelsd which is faster than dgelss 
.RE
.PP

.SS "void substitution_solve (RealMatrix & A, RealMatrix & B, RealMatrix & result, Teuchos::ETransp trans = \fCTeuchos::NO_TRANS\fP, Teuchos::EUplo uplo = \fCTeuchos::UPPER_TRI\fP, Teuchos::EDiag diag = \fCTeuchos::NON_UNIT_DIAG\fP)"

.PP
Solves a triangular system\&. Solves a triangular system of the form A * X = B or A**T * X = B,
.PP
where A is a triangular matrix of order N, and B is an N-by-NRHS matrix\&. A check is made to verify that A is nonsingular\&.
.PP
.SH "Arguments "
.PP
.PP
\fBParameters:\fP
.RS 4
\fIA\fP (input) DOUBLE PRECISION array, dimension (LDA,N) The triangular matrix A\&. If uplo = Teuchos::UPPER_TRI, the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced\&. If UPLO = LOWER_TRU, the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced\&. If DIAG = UNIT_DIAG, the diagonal elements of A are also not referenced and are assumed to be 1\&.
.br
\fIB\fP (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B\&. On exit, if INFO = 0, the solution matrix X\&.
.br
\fIresult\fP (output) DOUBLE PRECISION matrix, dimension (N,NRHS) On exit, X is the N-by-NRHS solution matrix\&.
.br
\fIuplo\fP Specifies whether A is upper or lower traingular
.br
\fItrans\fP Specifies the form of the system of equations: = Teuchos::NO_TRANS: A * X = B (No transpose) = TRANS : A**T * X = B (Transpose)
.br
\fIdiag\fP Specifies if the matrix is unit diagonal 
.RE
.PP

.SS "int qr_factorization_update_insert_column (RealMatrix & Q, RealMatrix & R, RealMatrix & col, int iter)"

.PP
Returns the QR factorization of [A a] given a qr factorization of A\&. QR facorization is $O(N^3)$ but this update is only $O(N^2)$
.PP
\fBParameters:\fP
.RS 4
\fIQ\fP (input/output) The ( M x iter ) orthogonal matrix\&. On entry contains the original ( M x tier-1 ) orthogonal matrix Q with an additional ( M x 1 ) possibly unitialized column allocated to allow the storage of the larger updated matrix Q\&. On exit Q is the updated orthogonal matrix factor appended to it \&. Must have all excess memory initialized to zero\&.
.br
\fIR\fP (input/output) The ( iter x iter ) upper triangular matrix\&. On entry contains the ( iter-1 x iter-1 ) original matrix R with memory allocated to allow the storage of the larger updated matrix R Must have all excess memory initialized to zero\&.
.br
\fIcol\fP (intput) the new column being added to A\&.
.br
\fIiter\fP specifies the size of the original Q and R matricies\&.
.RE
.PP
\fBReturns:\fP
.RS 4
info = 0 update sucessful\&. If info = 1, the new column was colinear with the active set\&. 
.RE
.PP

.SS "int cholesky_factorization_update_insert_column (RealMatrix & A, RealMatrix & U, RealMatrix & col, int iter, Real delta = \fC0\fP)"

.PP
Return the cholesky factorization of a positive definite grammian matrix [A a]'*[A a] given a cholesky factorization of A'*A\&. Cholesky facorization is $O(N^3)$ but this update is only $O(N^2)$
.PP
\fBParameters:\fP
.RS 4
\fIA\fP (output) The ( M x iter ) Matrix used to compute the gramian A'A
.br
\fIU\fP (input/output) The ( iter x iter ) upper triangular matrix\&. On entry contains the ( iter-1 x iter-1 ) original matrix U with memory allocated to allow the storage of the larger updated matrix U\&. Must have all excess memory initialized to zero\&.
.br
\fIcol\fP (intput) the new column being added to A\&.
.br
\fIiter\fP specifies the size of the original U matrix\&.
.br
\fIdelta\fP Regularization parameter\&. If delta > 0 the function will return chol( [A a]'*[A A] + delta*I )
.RE
.PP
\fBReturns:\fP
.RS 4
info = 0 update sucessful\&. If info = 1, the new column was colinear with the active set\&. 
.RE
.PP

.SS "void givens_rotation (RealVector & x, RealVector & x_rot, RealMatrix & givensMatrix)"

.PP
Compute the givens rotation of a (2x1) vector x and also returned the rotated vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP (intput) (2x1) vector to be rotated
.br
\fIx_rot\fP (ouput) (2x1) rotated vector
.RE
.PP
givensMatrix (ouput) (2x2) Givens rotation matrix 
.SS "void cholesky_factorization_update_delete_column (RealMatrix & U, int col_index, int N)"

.PP
Update the cholesky factorization of a positive definite grammian matrix A'A when a column is deleted from A\&. 
.PP
\fBParameters:\fP
.RS 4
\fIU\fP (input/output) The ( N x N ) upper triangular matrix\&. On entry contains the ( N x N ) original matrix U On exit containt the ( N-1 x N-1 ) new matrix U with all entries in the Nth row and column set to zero\&.
.br
\fIcol_index\fP The index of the column to be deleted from A
.br
\fIN\fP the number of rows and columns of U 
.RE
.PP

.SS "int conjugate_gradients_solve (RealMatrix & A, RealVector & b, RealVector & x, Real & r_norm, Real cg_tol = \fC1e\-8\fP, int max_iter = \fC50\fP, int verbosity = \fC1\fP)"
Calculate an approximate solution to Ax=b using the conjugate gradient method
.PP
\fBReturns:\fP
.RS 4
info = 0 update sucessful\&. If info = 1, the matrix is not positive definite\&. info = 2\&. the matrix contains inf or nan\&. 
.RE
.PP

.SS "void equality_constrained_least_squares_solve (RealMatrix & A, RealVector & b, RealMatrix & C, RealVector & d, RealMatrix & x, int verbosity = \fC0\fP)"

.PP
Solve the linear equality-constrained least squares (LSE) problem: minimize || b - A*x ||_2 subject to C*x = d
.PP
where A is an M-by-N matrix, C is a P-by-N matrix, b is a given M-vector, and d is a given P-vector\&. It is assumed that P <= N <= M+P, and 
.PP
.nf
     rank(C) = P and  rank( (A) ) = N.
                          ( (C) )

.fi
.PP
.PP
These conditions ensure that the LSE problem has a unique solution, which is obtained using a generalized RQ factorization of the matrices (C, A) given by
.PP
C = (0 R)*Q, A = Z*T*Q\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP (input) DOUBLE PRECISION M-by-N matrix A\&.
.br
\fIC\fP (input) DOUBLE PRECISION P-by-N matrix B\&.
.br
\fIb\fP (input) DOUBLE PRECISION M vector On entry, b contains the right hand side vector for the least squares part of the LSE problem\&.
.br
\fId\fP (input) DOUBLE PRECISION P vector On entry, d contains the right hand side vector for the constrained equation\&.
.br
\fIx\fP (output) DOUBLE PRECISION N -vector On exit, X is the solution of the LSE problem\&. 
.RE
.PP

.SS "void cholesky_inverse (RealMatrix & L, RealMatrix & result, Teuchos::EUplo uplo)"

.PP
Computes the inverse of a real symmetric positive definite matrix A using the Cholesky factorization A = L*L**T or A = U**T*U\&. 
.PP
\fBParameters:\fP
.RS 4
\fIU\fP (input) DOUBLE PRECISION NxN matrix U\&. U is the lower or upper traingular factor L or U from the Cholesky factorization A = L*L**T or A = U**T*U
.br
\fIresult\fP (output) DOUBLE PRECISION NxN matrix\&. On exit result is the inverse of A 
.RE
.PP

.SS "void truncated_pivoted_lu_factorization (RealMatrix & A, RealMatrix & result_0, RealMatrix & result_1, IntVector & values_0, int max_iters, int num_initial_rows)"

.PP
Compute an LU factorization with parital row pivoting of the m-by-n matrix A\&. The factorization has the form A = P * L * U where P is the permutation matrix, L is lower triangular with unit diagonal elements and U is upper triangular\&. /param max_iters the maximum number of pivots to perform\&. This is distinguishing feature from pivoted_lu_factorization() /param num_initial_rows The first n rows of A which must be included in the factorization before any other row can be included 
.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
