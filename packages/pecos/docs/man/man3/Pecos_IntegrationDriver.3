.TH "IntegrationDriver" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IntegrationDriver \- base class for generating N-dimensional grids for numerical evaluation of expectation integrals over independent standard random variables\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBCubatureDriver\fP, \fBSparseGridDriver\fP, and \fBTensorProductDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIntegrationDriver\fP ()"
.br
.RI "\fIdefault constructor \fP"
.ti -1c
.RI "\fBIntegrationDriver\fP (short driver_type)"
.br
.RI "\fIstandard constructor for envelope \fP"
.ti -1c
.RI "\fBIntegrationDriver\fP (const \fBIntegrationDriver\fP &driver)"
.br
.RI "\fIcopy constructor \fP"
.ti -1c
.RI "virtual \fB~IntegrationDriver\fP ()"
.br
.RI "\fIdestructor \fP"
.ti -1c
.RI "\fBIntegrationDriver\fP \fBoperator=\fP (const \fBIntegrationDriver\fP &driver)"
.br
.RI "\fIassignment operator \fP"
.ti -1c
.RI "virtual void \fBinitialize_grid\fP (const std::vector< \fBBasisPolynomial\fP > &poly_basis)"
.br
.RI "\fIinitialize all grid settings (distribution params already set within poly_basis) \fP"
.ti -1c
.RI "virtual void \fBinitialize_grid\fP (const ShortArray &u_types, const \fBExpansionConfigOptions\fP &ec_options, const \fBBasisConfigOptions\fP &bc_options)"
.br
.RI "\fIset int_rules and growth_rules from u_types and mode booleans \fP"
.ti -1c
.RI "virtual void \fBinitialize_grid_parameters\fP (const ShortArray &u_types, const \fBAleatoryDistParams\fP &adp)"
.br
.RI "\fIupdate polynomialBasis with data from \fBAleatoryDistParams\fP \fP"
.ti -1c
.RI "virtual void \fBcompute_grid\fP (RealMatrix &var_sets)"
.br
.RI "\fIcompute scaled variable and weight sets for the TPQ grid \fP"
.ti -1c
.RI "virtual int \fBgrid_size\fP ()"
.br
.RI "\fIcompute number of collocation points \fP"
.ti -1c
.RI "virtual void \fBreinterpolated_tensor_grid\fP (const UShortArray &lev_index, const SizetList &reinterp_indices)"
.br
.RI "\fIcomputes and stores data for reinterpolation of covariance on a higher-order tensor grid \fP"
.ti -1c
.RI "virtual void \fBstore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIstore configuration settings for the current grid before advancing to the next settings within a prescribed grid sequence (default is push_back) \fP"
.ti -1c
.RI "virtual void \fBrestore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIrestore configuration settings from a previously stored grid \fP"
.ti -1c
.RI "virtual void \fBremove_stored_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIremove configuration settings for a stored grid (default is pop_back) \fP"
.ti -1c
.RI "virtual void \fBclear_stored\fP ()"
.br
.RI "\fIclear stored grid settings following their usage/combination \fP"
.ti -1c
.RI "virtual size_t \fBmaximal_grid\fP () const "
.br
.RI "\fIreturn the index of the maximal stored grid state (_NPOS if the current unstored grid state) \fP"
.ti -1c
.RI "virtual void \fBswap_grid\fP (size_t index)"
.br
.RI "\fIswap settings between the current grid and the stored grid identified by index \fP"
.ti -1c
.RI "virtual const RealVector & \fBtype1_weight_sets\fP () const "
.br
.RI "\fIreturn type1WeightSets from Cubature/TensorProduct/CombinedSparseGrid or concatenate type1WeightSets in HierarchSparseGrid \fP"
.ti -1c
.RI "virtual const RealMatrix & \fBtype2_weight_sets\fP () const "
.br
.RI "\fIreturn type2WeightSets from Cubature/TensorProduct/CombinedSparseGrid or concatenate type2WeightSets in HierarchSparseGrid \fP"
.ti -1c
.RI "void \fBassign_rep\fP (\fBIntegrationDriver\fP *\fBdriver_rep\fP, bool ref_count_incr)"
.br
.RI "\fIassign letter or replace existing letter with a new one \fP"
.ti -1c
.RI "void \fBcompute_tensor_grid\fP (const UShortArray &quad_order, const UShortArray &lev_index, const SizetList &subset_indices, RealMatrix &variable_sets, UShort2DArray &colloc_key)"
.br
.RI "\fIcompute variable sets for a tensor-product grid \fP"
.ti -1c
.RI "void \fBupdate_1d_collocation_points_weights\fP (const UShortArray &quad_order, const UShortArray &lev_index)"
.br
.RI "\fIupdate collocPts1D and type{1,2}CollocWts1D \fP"
.ti -1c
.RI "const std::vector< \fBBasisPolynomial\fP > & \fBpolynomial_basis\fP () const "
.br
.RI "\fIreturn polynomialBasis \fP"
.ti -1c
.RI "void \fBmode\fP (short driver_mode)"
.br
.RI "\fIset driverMode \fP"
.ti -1c
.RI "short \fBmode\fP () const "
.br
.RI "\fIget driverMode \fP"
.ti -1c
.RI "const Real3DArray & \fBcollocation_points_1d\fP () const "
.br
.RI "\fIreturn collocPts1D \fP"
.ti -1c
.RI "const Real3DArray & \fBtype1_collocation_weights_1d\fP () const "
.br
.RI "\fIreturn type1CollocWts1D \fP"
.ti -1c
.RI "const Real3DArray & \fBtype2_collocation_weights_1d\fP () const "
.br
.RI "\fIreturn type2CollocWts1D \fP"
.ti -1c
.RI "const ShortArray & \fBcollocation_rules\fP () const "
.br
.RI "\fIreturn collocRules \fP"
.ti -1c
.RI "const UShortArray & \fBreinterpolated_level_index\fP () const "
.br
.RI "\fIreturn reinterpLevelIndices[activeReinterpIndex] \fP"
.ti -1c
.RI "const UShortArray & \fBreinterpolated_quadrature_order\fP () const "
.br
.RI "\fIreturn reinterpQuadOrders[activeReinterpIndex] \fP"
.ti -1c
.RI "const RealMatrix & \fBreinterpolated_variable_sets\fP () const "
.br
.RI "\fIreturn reinterpVarSets[activeReinterpIndex] \fP"
.ti -1c
.RI "const UShort2DArray & \fBreinterpolated_collocation_key\fP () const "
.br
.RI "\fIreturn reinterpCollocKeys[activeReinterpIndex] \fP"
.ti -1c
.RI "const UShortArray & \fBgenz_keister_order\fP () const "
.br
.RI "\fIreturn orderGenzKeister \fP"
.ti -1c
.RI "const UShortArray & \fBgenz_keister_precision\fP () const "
.br
.RI "\fIreturn precGenzKeister \fP"
.ti -1c
.RI "\fBIntegrationDriver\fP * \fBdriver_rep\fP () const "
.br
.RI "\fIreturns driverRep for access to derived class member functions that are not mapped to the base level \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBIntegrationDriver\fP (\fBBaseConstructor\fP)"
.br
.RI "\fIconstructor initializes the base class part of letter classes (\fBBaseConstructor\fP overloading avoids infinite recursion in the derived class constructors - Coplien, p\&. 139) \fP"
.ti -1c
.RI "void \fBcompute_tensor_grid\fP (const UShortArray &quad_order, const UShortArray &lev_index, RealMatrix &variable_sets, RealVector &t1_weight_sets, RealMatrix &t2_weight_sets, UShort2DArray &colloc_key)"
.br
.RI "\fIcompute variable and weight sets for a tensor-product grid \fP"
.ti -1c
.RI "void \fBupdate_1d_collocation_points_weights\fP (const UShortArray &quad_order, const UShortArray &lev_index, const SizetList &subset_indices)"
.br
.RI "\fIupdate collocPts1D and type{1,2}CollocWts1D for subset variables \fP"
.ti -1c
.RI "void \fBassign_1d_collocation_points_weights\fP (size_t i, unsigned short quad_order, unsigned short lev_index)"
.br
.RI "\fIupdate collocPts1D[lev_index][i] and type{1,2}CollocWts1D[lev_index][i] \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBnumVars\fP"
.br
.RI "\fInumber of variables in the tensor-product grid \fP"
.ti -1c
.RI "short \fBdriverMode\fP"
.br
.RI "\fIenumeration value indicating INTEGRATION_MODE or INTERPOLATION_MODE \fP"
.ti -1c
.RI "ShortArray \fBcollocRules\fP"
.br
.RI "\fIenumeration codes for integration rule options\&. Manages internal mode switches for 1D polynomial types: e\&.g\&., GAUSS_LEGENDRE or GAUSS_PATTERSON for Legendre, CLENSHAW_CURTIS or FEJER2 for Chebyshev, GAUSS_HERMITE or GENZ_KEISTER for Hermite\&. \fP"
.ti -1c
.RI "std::vector< \fBBasisPolynomial\fP > \fBpolynomialBasis\fP"
.br
.RI "\fIarray of one-dimensional orthogonal polynomials used in computing Gaussian quadrature points and weights \fP"
.ti -1c
.RI "Real3DArray \fBcollocPts1D\fP"
.br
.RI "\fInum_levels_per_var x numVars sets of 1D collocation points \fP"
.ti -1c
.RI "Real3DArray \fBtype1CollocWts1D\fP"
.br
.RI "\fInum_levels_per_var x numVars sets of 1D type1 collocation weights \fP"
.ti -1c
.RI "Real3DArray \fBtype2CollocWts1D\fP"
.br
.RI "\fInum_levels_per_var x numVars sets of 1D type2 collocation weights \fP"
.ti -1c
.RI "bool \fBcomputeType2Weights\fP"
.br
.RI "\fIflag indicating usage of compute1DType2Weights to define type2WeightSets \fP"
.ti -1c
.RI "UShort2DArray \fBreinterpLevelIndices\fP"
.br
.RI "\fIbookkeeping for reinterpolation of covariance: stored level indices \fP"
.ti -1c
.RI "UShort2DArray \fBreinterpQuadOrders\fP"
.br
.RI "\fIbookkeeping for reinterpolation of covariance: stored quadrature orders \fP"
.ti -1c
.RI "RealMatrixArray \fBreinterpVarSets\fP"
.br
.RI "\fIbookkeeping for reinterpolation of covariance: stored variable sets \fP"
.ti -1c
.RI "UShort3DArray \fBreinterpCollocKeys\fP"
.br
.RI "\fIbookkeeping for reinterpolation of covariance: stored collocation keys \fP"
.ti -1c
.RI "std::map< UShortArray, size_t > \fBreinterpMap\fP"
.br
.RI "\fItracks existing reinterpolation grids to avoid unnecessary recomputation \fP"
.ti -1c
.RI "size_t \fBactiveReinterpIndex\fP"
.br
.RI "\fIbookkeeping for reinterpolation of covariance: active index into arrays \fP"
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static UShortArray \fBorderGenzKeister\fP"
.br
.RI "\fIlookup for set of 1-D Genz-Keister quadrature orders \fP"
.ti -1c
.RI "static UShortArray \fBprecGenzKeister\fP"
.br
.RI "\fIlookup for set of 1-D Genz-Keister integrand precisions \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBIntegrationDriver\fP * \fBget_driver\fP (short driver_type)"
.br
.RI "\fIUsed only by the standard envelope constructor to initialize driverRep to the appropriate derived type\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBIntegrationDriver\fP * \fBdriverRep\fP"
.br
.RI "\fIpointer to the letter (initialized only for the envelope) \fP"
.ti -1c
.RI "int \fBreferenceCount\fP"
.br
.RI "\fInumber of objects sharing driverRep \fP"
.in -1c
.SH "Detailed Description"
.PP 
base class for generating N-dimensional grids for numerical evaluation of expectation integrals over independent standard random variables\&. 

This class enables Dakota::NonD{Quadrature,Cubature,SparseGrid}\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBIntegrationDriver\fP ()"

.PP
default constructor The default constructor: driverRep is NULL in this case\&. This makes it necessary to check for NULL in the copy constructor, assignment operator, and destructor\&. 
.SS "\fBIntegrationDriver\fP (short driver_type)"

.PP
standard constructor for envelope Envelope constructor only needs to extract enough data to properly execute get_driver, since \fBIntegrationDriver(BaseConstructor)\fP builds the actual base class data for the derived basis functions\&. 
.PP
References IntegrationDriver::driverRep, and IntegrationDriver::get_driver()\&.
.SS "\fBIntegrationDriver\fP (const \fBIntegrationDriver\fP & driver)"

.PP
copy constructor Copy constructor manages sharing of driverRep and incrementing of referenceCount\&. 
.PP
References IntegrationDriver::driverRep, and IntegrationDriver::referenceCount\&.
.SS "~\fBIntegrationDriver\fP ()\fC [virtual]\fP"

.PP
destructor Destructor decrements referenceCount and only deletes driverRep when referenceCount reaches zero\&. 
.PP
References IntegrationDriver::assign_rep(), IntegrationDriver::driverRep, and IntegrationDriver::referenceCount\&.
.SS "\fBIntegrationDriver\fP (\fBBaseConstructor\fP)\fC [protected]\fP"

.PP
constructor initializes the base class part of letter classes (\fBBaseConstructor\fP overloading avoids infinite recursion in the derived class constructors - Coplien, p\&. 139) This constructor is the one which must build the base class data for all derived classes\&. \fBget_driver()\fP instantiates a derived class letter and the derived constructor selects this base class constructor in its initialization list (to avoid recursion in the base class constructor calling \fBget_driver()\fP again)\&. Since the letter IS the representation, its rep pointer is set to NULL (an uninitialized pointer causes problems in ~IntegrationDriver)\&. 
.PP
References IntegrationDriver::orderGenzKeister, and IntegrationDriver::precGenzKeister\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBIntegrationDriver\fP operator= (const \fBIntegrationDriver\fP & driver)"

.PP
assignment operator Assignment operator decrements referenceCount for old driverRep, assigns new driverRep, and increments referenceCount for new driverRep\&. 
.PP
References IntegrationDriver::driverRep, and IntegrationDriver::referenceCount\&.
.SS "void initialize_grid (const std::vector< \fBBasisPolynomial\fP > & poly_basis)\fC [virtual]\fP"

.PP
initialize all grid settings (distribution params already set within poly_basis) protected function called only from derived class letters\&. 
.PP
Reimplemented in \fBTensorProductDriver\fP, \fBCombinedSparseGridDriver\fP, and \fBCubatureDriver\fP\&.
.PP
References IntegrationDriver::collocRules, IntegrationDriver::computeType2Weights, IntegrationDriver::driverRep, IntegrationDriver::initialize_grid(), IntegrationDriver::numVars, and IntegrationDriver::polynomialBasis\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::allocate_data(), IntegrationDriver::initialize_grid(), CombinedSparseGridDriver::initialize_grid(), SparseGridDriver::initialize_grid(), TensorProductDriver::initialize_grid(), and IntegrationDriver::type2_weight_sets()\&.
.SS "void initialize_grid (const ShortArray & u_types, const \fBExpansionConfigOptions\fP & ec_options, const \fBBasisConfigOptions\fP & bc_options)\fC [virtual]\fP"

.PP
set int_rules and growth_rules from u_types and mode booleans protected function called only from derived class letters\&. 
.PP
Reimplemented in \fBTensorProductDriver\fP\&.
.PP
References IntegrationDriver::collocRules, IntegrationDriver::computeType2Weights, IntegrationDriver::driverMode, ExpansionConfigOptions::expBasisType, SharedInterpPolyApproxData::initialize_driver_types_rules(), IntegrationDriver::initialize_grid(), SharedPolyApproxData::initialize_orthogonal_basis_types_rules(), SharedPolyApproxData::initialize_polynomial_basis(), IntegrationDriver::numVars, and IntegrationDriver::polynomialBasis\&.
.SS "\fBIntegrationDriver\fP * get_driver (short driver_type)\fC [private]\fP"

.PP
Used only by the standard envelope constructor to initialize driverRep to the appropriate derived type\&. Used only by the envelope constructor to initialize driverRep to the appropriate derived type\&. 
.PP
Referenced by IntegrationDriver::IntegrationDriver()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
