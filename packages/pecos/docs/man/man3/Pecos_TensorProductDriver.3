.TH "TensorProductDriver" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TensorProductDriver \- generates N-dimensional tensor-product quadrature grids for numerical evaluation of expectation integrals over independent standard random variables\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBIntegrationDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTensorProductDriver\fP ()"
.br
.RI "\fIdefault constructor \fP"
.ti -1c
.RI "\fBTensorProductDriver\fP (const UShortArray &quad_order)"
.br
.RI "\fIconstructor \fP"
.ti -1c
.RI "\fB~TensorProductDriver\fP ()"
.br
.RI "\fIdestructor \fP"
.ti -1c
.RI "void \fBcompute_grid\fP (RealMatrix &variable_sets)"
.br
.RI "\fIcompute scaled variable and weight sets for the TPQ grid \fP"
.ti -1c
.RI "int \fBgrid_size\fP ()"
.br
.RI "\fIcompute number of collocation points \fP"
.ti -1c
.RI "void \fBreinterpolated_tensor_grid\fP (const UShortArray &lev_index, const SizetList &reinterp_indices)"
.br
.RI "\fIcomputes and stores data for reinterpolation of covariance on a higher-order tensor grid \fP"
.ti -1c
.RI "void \fBstore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIstore configuration settings for the current grid before advancing to the next settings within a prescribed grid sequence (default is push_back) \fP"
.ti -1c
.RI "void \fBrestore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIrestore configuration settings from a previously stored grid \fP"
.ti -1c
.RI "void \fBremove_stored_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIremove configuration settings for a stored grid (default is pop_back) \fP"
.ti -1c
.RI "void \fBclear_stored\fP ()"
.br
.RI "\fIclear stored grid settings following their usage/combination \fP"
.ti -1c
.RI "size_t \fBmaximal_grid\fP () const "
.br
.RI "\fIreturn the index of the maximal stored grid state (_NPOS if the current unstored grid state) \fP"
.ti -1c
.RI "void \fBswap_grid\fP (size_t index)"
.br
.RI "\fIswap settings between the current grid and the stored grid identified by index \fP"
.ti -1c
.RI "void \fBquadrature_order\fP (const UShortArray &quad_order)"
.br
.RI "\fIset quadOrder \fP"
.ti -1c
.RI "void \fBquadrature_order\fP (unsigned short order, size_t i)"
.br
.RI "\fIset ith entry in quadOrder \fP"
.ti -1c
.RI "const UShortArray & \fBquadrature_order\fP () const "
.br
.RI "\fIreturn quadOrder \fP"
.ti -1c
.RI "unsigned short \fBquadrature_order\fP (size_t i) const "
.br
.RI "\fIreturn ith entry in quadOrder \fP"
.ti -1c
.RI "void \fBintegrand_goal_to_nested_quadrature_order\fP (size_t i, unsigned short integrand_goal, unsigned short &nested_quad_order)"
.br
.RI "\fIdetermine the lowest quadrature order that provides integrand exactness at least as great as the specified goal, while satisfying any nestedness constraints \fP"
.ti -1c
.RI "void \fBquadrature_goal_to_nested_quadrature_order\fP (size_t i, unsigned short quad_goal, unsigned short &nested_quad_order)"
.br
.RI "\fIdetermine the lowest quadrature order that provides at least as many points as the specified goal, while satisfying any nestedness constraints \fP"
.ti -1c
.RI "void \fBnested_quadrature_order\fP (const UShortArray &ref_quad_order)"
.br
.RI "\fIupdate quadOrder and levelIndex from ref_quad_order while satisfying nested rule constraints \fP"
.ti -1c
.RI "const RealVector & \fBtype1_weight_sets\fP () const "
.br
.RI "\fIreturn type1WeightSets \fP"
.ti -1c
.RI "const RealMatrix & \fBtype2_weight_sets\fP () const "
.br
.RI "\fIreturn type2WeightSets \fP"
.ti -1c
.RI "const UShortArray & \fBlevel_index\fP () const "
.br
.RI "\fIreturn levelIndex \fP"
.ti -1c
.RI "const UShort2DArray & \fBcollocation_key\fP () const "
.br
.RI "\fIreturn collocKey \fP"
.ti -1c
.RI "const UShortArray & \fBstored_level_index\fP (size_t index) const "
.br
.RI "\fIreturn storedLevelIndex[index] \fP"
.ti -1c
.RI "const UShort2DArray & \fBstored_collocation_key\fP (size_t index) const "
.br
.RI "\fIreturn storedCollocKey[index] \fP"
.ti -1c
.RI "void \fBinitialize_grid\fP (const ShortArray &u_types, const \fBExpansionConfigOptions\fP &ec_options, const \fBBasisConfigOptions\fP &bc_options)"
.br
.RI "\fIstand-alone initializer of tensor grid settings (except for distribution params) \fP"
.ti -1c
.RI "void \fBinitialize_grid\fP (const std::vector< \fBBasisPolynomial\fP > &poly_basis)"
.br
.RI "\fIhelper initializer of tensor grid settings (except distribution params) \fP"
.ti -1c
.RI "void \fBprecompute_rules\fP ()"
.br
.RI "\fIprecompute quadrature rules to the maximum current order for each basis polynomial (efficiency optimization when rules are expensive to compute) \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdate_level_index_from_quadrature_order\fP ()"
.br
.RI "\fIupdate levelIndex from quadOrder \fP"
.ti -1c
.RI "void \fBupdate_level_index_from_quadrature_order\fP (size_t i)"
.br
.RI "\fIupdate levelIndex[i] from quadOrder[i] \fP"
.ti -1c
.RI "void \fBupdate_quadrature_order_from_level_index\fP ()"
.br
.RI "\fIupdate quadOrder from levelIndex \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "UShortArray \fBquadOrder\fP"
.br
.RI "\fIthe isotropic/anisotropic quadrature order \fP"
.ti -1c
.RI "UShortArray \fBlevelIndex\fP"
.br
.RI "\fIquadrature order offset by one for use as 0-based indices \fP"
.ti -1c
.RI "UShort2DArray \fBcollocKey\fP"
.br
.RI "\fInum points-by-numVars array for identifying the 1-D point indices for sets of tensor-product collocation points \fP"
.ti -1c
.RI "UShort2DArray \fBstoredLevelIndex\fP"
.br
.RI "\fIstored driver states: copies of levelIndex \fP"
.ti -1c
.RI "UShort3DArray \fBstoredCollocKey\fP"
.br
.RI "\fIstored driver states: copies of collocKey \fP"
.ti -1c
.RI "RealVector \fBtype1WeightSets\fP"
.br
.RI "\fIthe set of type1 weights (for integration of value interpolants) associated with each point in the tensor grid \fP"
.ti -1c
.RI "RealMatrix \fBtype2WeightSets\fP"
.br
.RI "\fIthe set of type2 weights (for integration of gradient interpolants) for each derivative component and for each point in the tensor grid \fP"
.ti -1c
.RI "RealVectorArray \fBstoredType1WeightSets\fP"
.br
.RI "\fIstored driver states: copies of type1WeightSets \fP"
.ti -1c
.RI "RealMatrixArray \fBstoredType2WeightSets\fP"
.br
.RI "\fIstored driver states: copies of type2WeightSets \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
generates N-dimensional tensor-product quadrature grids for numerical evaluation of expectation integrals over independent standard random variables\&. 

This class is used by Dakota::NonDQuadrature, but could also be used for general numerical integration of moments\&. 
.SH "Member Function Documentation"
.PP 
.SS "void integrand_goal_to_nested_quadrature_order (size_t i, unsigned short integrand_goal, unsigned short & nested_quad_order)"

.PP
determine the lowest quadrature order that provides integrand exactness at least as great as the specified goal, while satisfying any nestedness constraints This function selects the smallest nested rule order that meets the integrand precision of a corresponding Gauss rule\&. It is similar to the moderate exponential growth option in sparse grids\&. 
.PP
References IntegrationDriver::collocRules, IntegrationDriver::orderGenzKeister, IntegrationDriver::precGenzKeister, and TensorProductDriver::quadrature_goal_to_nested_quadrature_order()\&.
.PP
Referenced by TensorProductDriver::nested_quadrature_order(), and TensorProductDriver::swap_grid()\&.
.SS "void quadrature_goal_to_nested_quadrature_order (size_t i, unsigned short quad_goal, unsigned short & nested_quad_order)"

.PP
determine the lowest quadrature order that provides at least as many points as the specified goal, while satisfying any nestedness constraints This function selects the smallest nested rule order that meets the quadrature order goal\&. 
.PP
References IntegrationDriver::collocRules, IntegrationDriver::orderGenzKeister, and TensorProductDriver::reinterpolated_tensor_grid()\&.
.PP
Referenced by TensorProductDriver::integrand_goal_to_nested_quadrature_order(), and TensorProductDriver::nested_quadrature_order()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
