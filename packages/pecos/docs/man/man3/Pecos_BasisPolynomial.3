.TH "BasisPolynomial" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BasisPolynomial \- Base class for the basis polynomial class hierarchy\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBInterpolationPolynomial\fP, and \fBOrthogonalPolynomial\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBasisPolynomial\fP ()"
.br
.RI "\fIdefault constructor \fP"
.ti -1c
.RI "\fBBasisPolynomial\fP (short poly_type, short rule=0)"
.br
.RI "\fIalternate constructor \fP"
.ti -1c
.RI "\fBBasisPolynomial\fP (const \fBBasisPolynomial\fP &polynomial)"
.br
.RI "\fIcopy constructor \fP"
.ti -1c
.RI "virtual \fB~BasisPolynomial\fP ()"
.br
.RI "\fIdestructor \fP"
.ti -1c
.RI "\fBBasisPolynomial\fP \fBoperator=\fP (const \fBBasisPolynomial\fP &polynomial)"
.br
.RI "\fIassignment operator \fP"
.ti -1c
.RI "virtual Real \fBtype1_value\fP (unsigned short n)"
.br
.RI "\fIretrieve the value of the n_th type 1 polynomial for a given parameter x using barycentric formulation \fP"
.ti -1c
.RI "virtual Real \fBtype1_value\fP (Real x, unsigned short n)"
.br
.RI "\fIretrieve the value of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation \fP"
.ti -1c
.RI "virtual Real \fBtype2_value\fP (Real x, unsigned short n)"
.br
.RI "\fIretrieve the value of the n_th type 2 polynomial for a given parameter x \fP"
.ti -1c
.RI "virtual Real \fBtype1_gradient\fP (unsigned short n)"
.br
.RI "\fIretrieve the gradient of the n_th type 1 polynomial for a given parameter x using barycentric formulation \fP"
.ti -1c
.RI "virtual Real \fBtype1_gradient\fP (Real x, unsigned short n)"
.br
.RI "\fIretrieve the gradient of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation \fP"
.ti -1c
.RI "virtual Real \fBtype2_gradient\fP (Real x, unsigned short n)"
.br
.RI "\fIretrieve the gradient of the n_th type 2 polynomial for a given parameter x \fP"
.ti -1c
.RI "virtual Real \fBtype1_hessian\fP (Real x, unsigned short n)"
.br
.RI "\fIretrieve the Hessian of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation \fP"
.ti -1c
.RI "virtual Real \fBnorm_squared\fP (unsigned short n)"
.br
.RI "\fIreturns the norm-squared of the n_th order polynomial defined by the inner product <Poly_n, Poly_n> = ||Poly_n||^2 \fP"
.ti -1c
.RI "virtual const RealArray & \fBcollocation_points\fP (unsigned short n)"
.br
.RI "\fIreturn collocation points corresponding to orthogonal polynomial order n \fP"
.ti -1c
.RI "virtual const RealArray & \fBtype1_collocation_weights\fP (unsigned short order)"
.br
.RI "\fIreturn the type 1 collocation weights corresponding to a point set of size order \fP"
.ti -1c
.RI "virtual const RealArray & \fBtype2_collocation_weights\fP (unsigned short order)"
.br
.RI "\fIreturn the type 2 collocation weights corresponding to a point set of size order \fP"
.ti -1c
.RI "virtual void \fBset_new_point\fP (Real x, short order)"
.br
.RI "\fIfor barycentric interpolation, set the point to be interpolated for purposes of precomputation of nodal value/gradient factors \fP"
.ti -1c
.RI "virtual void \fBset_new_point\fP (Real x, short order, const UShortArray &delta_key)"
.br
.RI "\fIfor barycentric interpolation, set the point to be interpolated for purposes of precomputation of hierarchical value/gradient factors \fP"
.ti -1c
.RI "virtual size_t \fBexact_index\fP () const "
.br
.RI "\fIreturns the index of a collocation point that is an exact match with the point to be interpolated (from \fBset_new_point()\fP) if detected (_NPOS if not) \fP"
.ti -1c
.RI "virtual size_t \fBexact_delta_index\fP () const "
.br
.RI "\fIreturns the index of a hierarchical increment to the interpolation points that is an exact match with the point to be interpolated (from \fBset_new_point()\fP) if detected (_NPOS if not) \fP"
.ti -1c
.RI "virtual const RealVector & \fBbarycentric_value_factors\fP () const "
.br
.RI "\fIreturn the barycentric value factors \fP"
.ti -1c
.RI "virtual Real \fBbarycentric_value_factor\fP (unsigned short i) const "
.br
.RI "\fIreturn a particular barycentric value factor \fP"
.ti -1c
.RI "virtual const RealVector & \fBbarycentric_gradient_factors\fP () const "
.br
.RI "\fIreturn the barycentric gradient factors \fP"
.ti -1c
.RI "virtual Real \fBbarycentric_gradient_factor\fP (unsigned short i) const "
.br
.RI "\fIreturn a particular barycentric gradient factor \fP"
.ti -1c
.RI "virtual Real \fBbarycentric_value_factor_sum\fP () const "
.br
.RI "\fIreturn the sum of all barycentric value factors for use in computing the barycentric interpolant denominator \fP"
.ti -1c
.RI "virtual Real \fBbarycentric_difference_product\fP () const "
.br
.RI "\fIreturn the product of all differences between the interpolation points and a current point \fP"
.ti -1c
.RI "virtual void \fBreset_gauss\fP ()"
.br
.RI "\fIdestroy history of Gauss pts/wts (due to distribution parameter changes) \fP"
.ti -1c
.RI "virtual Real \fBpoint_factor\fP ()"
.br
.RI "\fI(calculate and) return ptFactor \fP"
.ti -1c
.RI "virtual Real \fBweight_factor\fP ()"
.br
.RI "\fI(calculate and) return wtFactor \fP"
.ti -1c
.RI "virtual Real \fBalpha_polynomial\fP () const "
.br
.RI "\fIreturn {Jacobi,GenLaguerre}OrthogPolynomial::alphaPoly \fP"
.ti -1c
.RI "virtual Real \fBbeta_polynomial\fP () const "
.br
.RI "\fIreturn \fBJacobiOrthogPolynomial::betaPoly\fP \fP"
.ti -1c
.RI "virtual void \fBalpha_stat\fP (Real alpha)"
.br
.RI "\fIset \fBJacobiOrthogPolynomial::betaPoly\fP or \fBGenLaguerreOrthogPolynomial::alphaPoly\fP from statistical defn of alpha \fP"
.ti -1c
.RI "virtual void \fBbeta_stat\fP (Real beta)"
.br
.RI "\fIset \fBJacobiOrthogPolynomial::alphaPoly\fP from statistical defn of beta \fP"
.ti -1c
.RI "virtual void \fBcollocation_rule\fP (short rule)"
.br
.RI "\fIset \fBOrthogonalPolynomial::collocRule\fP \fP"
.ti -1c
.RI "virtual short \fBcollocation_rule\fP () const "
.br
.RI "\fIget \fBOrthogonalPolynomial::collocRule\fP \fP"
.ti -1c
.RI "virtual size_t \fBinterpolation_size\fP () const "
.br
.RI "\fIget size of \fBInterpolationPolynomial::interpPts\fP \fP"
.ti -1c
.RI "virtual void \fBinterpolation_points\fP (const RealArray &interpolation_pts)"
.br
.RI "\fIset \fBInterpolationPolynomial::interpPts\fP \fP"
.ti -1c
.RI "virtual const RealArray & \fBinterpolation_points\fP () const "
.br
.RI "\fIget \fBInterpolationPolynomial::interpPts\fP \fP"
.ti -1c
.RI "virtual bool \fBparameterized\fP () const "
.br
.RI "\fIreturn whether a derived \fBBasisPolynomial\fP type supports parameterization \fP"
.ti -1c
.RI "virtual Real \fBlength_scale\fP () const "
.br
.RI "\fIreturn a characteristic length scale for the probability distribution associated with an orthogonal polynomial basis \fP"
.ti -1c
.RI "virtual void \fBprecompute_rules\fP (unsigned short order)"
.br
.RI "\fIprecompute quadrature rules up to specified order \fP"
.ti -1c
.RI "short \fBbasis_type\fP () const "
.br
.RI "\fIreturn basisPolyType \fP"
.ti -1c
.RI "bool \fBparametric_update\fP () const "
.br
.RI "\fIreturn parametricUpdate \fP"
.ti -1c
.RI "\fBBasisPolynomial\fP * \fBpolynomial_rep\fP () const "
.br
.RI "\fIreturns polyRep for access to derived class member functions that are not mapped to the top \fBBasisPolynomial\fP level \fP"
.ti -1c
.RI "bool \fBis_null\fP () const "
.br
.RI "\fIfunction to check polyRep (does this handle contain a body) \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static Real \fBfactorial\fP (unsigned short n)"
.br
.RI "\fIcompute n! \fP"
.ti -1c
.RI "static Real \fBfactorial_ratio\fP (unsigned short num, unsigned short den)"
.br
.RI "\fIcompute num!/den! \fP"
.ti -1c
.RI "static Real \fBn_choose_k\fP (unsigned short n, unsigned short k)"
.br
.RI "\fIcompute n!/(k!(n-k)!) \fP"
.ti -1c
.RI "static Real \fBpochhammer\fP (Real m, unsigned short n)"
.br
.RI "\fIcompute the Pochhammer symbol (m)_n = m*(m+1)\&.\&.\&.*(m+n-1) \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBBasisPolynomial\fP (\fBBaseConstructor\fP)"
.br
.RI "\fIconstructor initializes the base class part of letter classes (\fBBaseConstructor\fP overloading avoids infinite recursion in the derived class constructors - Coplien, p\&. 139) \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "short \fBbasisPolyType\fP"
.br
.RI "\fIbasis polynomial type: {HERMITE,LEGENDRE,LAGUERRE,JACOBI,GEN_LAGUERRE,NUM_GEN}_ORTHOG, {LAGRANGE,HERMITE}_INTERP, or PIECEWISE_{LINEAR,QUADRATIC,CUBIC}_INTERP \fP"
.ti -1c
.RI "bool \fBparametricUpdate\fP"
.br
.RI "\fIflag indicating presence of a parametric update to the basis polynomial, such that previous points/weights may not be reused \fP"
.ti -1c
.RI "Real \fBwtFactor\fP"
.br
.RI "\fIweight discrepancy factor between Abramowitz-Stegun and PDF orthogonality \fP"
.ti -1c
.RI "Real \fBptFactor\fP"
.br
.RI "\fIpoint discrepancy factor between Abramowitz-Stegun and PDF orthogonality \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBBasisPolynomial\fP * \fBget_polynomial\fP (short poly_type, short rule)"
.br
.RI "\fIUsed by the envelope constructor to initialize polyRep to the appropriate derived type\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBBasisPolynomial\fP * \fBpolyRep\fP"
.br
.RI "\fIpointer to the letter (initialized only for the envelope) \fP"
.ti -1c
.RI "int \fBreferenceCount\fP"
.br
.RI "\fInumber of objects sharing polyRep \fP"
.in -1c
.SH "Detailed Description"
.PP 
Base class for the basis polynomial class hierarchy\&. 

The \fBBasisPolynomial\fP class is the base class for the univariate basis polynomial class hierarchy in PECOS\&. One instance of an \fBBasisPolynomial\fP is created for each variable within a multidimensional polynomial basis function (a vector of BasisPolynomials is contained in BasisPolyApproximation, which may be mixed and matched in, e\&.g\&., the Wiener-Askey scheme for polynomial chaos)\&. For memory efficiency and enhanced polymorphism, the basis polynomial hierarchy employs the 'letter/envelope idiom' (see Coplien 'Advanced C++', p\&. 133), for which the base class (\fBBasisPolynomial\fP) serves as the envelope and one of the derived classes (selected in \fBBasisPolynomial::get_polynomial()\fP) serves as the letter\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBasisPolynomial\fP ()"

.PP
default constructor The default constructor is used in Array<BasisPolynomial> instantiations and by the alternate envelope constructor\&. polyRep is NULL in this case (problem_db is needed to build a meaningful instance)\&. This makes it necessary to check for NULL in the copy constructor, assignment operator, and destructor\&. 
.SS "\fBBasisPolynomial\fP (short poly_type, short rule = \fC0\fP)"

.PP
alternate constructor Envelope constructor which does not require access to problem_db\&. This constructor executes get_polynomial(type), which invokes the default constructor of the derived letter class, which in turn invokes the \fBBaseConstructor\fP of the base class\&. 
.PP
References BasisPolynomial::get_polynomial(), and BasisPolynomial::polyRep\&.
.SS "\fBBasisPolynomial\fP (const \fBBasisPolynomial\fP & polynomial)"

.PP
copy constructor Copy constructor manages sharing of polyRep and incrementing of referenceCount\&. 
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::referenceCount\&.
.SS "~\fBBasisPolynomial\fP ()\fC [virtual]\fP"

.PP
destructor Destructor decrements referenceCount and only deletes polyRep when referenceCount reaches zero\&. 
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::referenceCount\&.
.SS "\fBBasisPolynomial\fP (\fBBaseConstructor\fP)\fC [protected]\fP"

.PP
constructor initializes the base class part of letter classes (\fBBaseConstructor\fP overloading avoids infinite recursion in the derived class constructors - Coplien, p\&. 139) This constructor is the one which must build the base class data for all derived classes\&. \fBget_polynomial()\fP instantiates a derived class letter and the derived constructor selects this base class constructor in its initialization list (to avoid recursion in the base class constructor calling \fBget_polynomial()\fP again)\&. Since the letter IS the representation, its rep pointer is set to NULL (an uninitialized pointer causes problems in ~BasisPolynomial)\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBBasisPolynomial\fP operator= (const \fBBasisPolynomial\fP & polynomial)"

.PP
assignment operator Assignment operator decrements referenceCount for old polyRep, assigns new polyRep, and increments referenceCount for new polyRep\&. 
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::referenceCount\&.
.SS "Real type1_value (unsigned short n)\fC [virtual]\fP"

.PP
retrieve the value of the n_th type 1 polynomial for a given parameter x using barycentric formulation For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBLagrangeInterpPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_value()\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::accumulate_horners(), SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), SharedNodalInterpPolyApproxData::basis_product_1d(), OrthogonalPolynomial::gauss_check(), OrthogonalPolynomial::precompute_triple_products(), NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tensor_product_mean(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), SharedProjectOrthogPolyApproxData::tensor_product_value(), SharedInterpPolyApproxData::tensor_product_value(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and BasisPolynomial::type1_value()\&.
.SS "Real type1_value (Real x, unsigned short n)\fC [virtual]\fP"

.PP
retrieve the value of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBHahnOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBMeixnerOrthogPolynomial\fP, \fBLagrangeInterpPolynomial\fP, \fBKrawtchoukOrthogPolynomial\fP, \fBPiecewiseInterpPolynomial\fP, \fBHermiteInterpPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, \fBHermiteOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_value()\&.
.SS "Real type2_value (Real x, unsigned short n)\fC [virtual]\fP"

.PP
retrieve the value of the n_th type 2 polynomial for a given parameter x For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBPiecewiseInterpPolynomial\fP, and \fBHermiteInterpPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type2_value()\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::accumulate_horners(), SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tensor_product_mean(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), SharedInterpPolyApproxData::tensor_product_value(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and BasisPolynomial::type2_value()\&.
.SS "Real type1_gradient (unsigned short n)\fC [virtual]\fP"

.PP
retrieve the gradient of the n_th type 1 polynomial for a given parameter x using barycentric formulation For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBLagrangeInterpPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_gradient()\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), SharedOrthogPolyApproxData::gradient_check(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and BasisPolynomial::type1_gradient()\&.
.SS "Real type1_gradient (Real x, unsigned short n)\fC [virtual]\fP"

.PP
retrieve the gradient of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBLagrangeInterpPolynomial\fP, \fBPiecewiseInterpPolynomial\fP, \fBHermiteInterpPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, \fBHermiteOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_gradient()\&.
.SS "Real type2_gradient (Real x, unsigned short n)\fC [virtual]\fP"

.PP
retrieve the gradient of the n_th type 2 polynomial for a given parameter x For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBPiecewiseInterpPolynomial\fP, and \fBHermiteInterpPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type2_gradient()\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), NodalInterpPolyApproximation::tensor_product_variance_gradient(), and BasisPolynomial::type2_gradient()\&.
.SS "Real type1_hessian (Real x, unsigned short n)\fC [virtual]\fP"

.PP
retrieve the Hessian of the n_th type 1 polynomial for a given parameter x using traditional characteristic polynomial formulation For orthogonal polynomials, n specifies the order of the polynomial, whereas for interpolation polynomials, it identifies the interpolant for the n-th point\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, \fBHermiteOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_hessian()\&.
.PP
Referenced by BasisPolynomial::type1_hessian()\&.
.SS "Real norm_squared (unsigned short n)\fC [virtual]\fP"

.PP
returns the norm-squared of the n_th order polynomial defined by the inner product <Poly_n, Poly_n> = ||Poly_n||^2 This is defined only for orthogonal polynomials\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, \fBHermiteOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::norm_squared(), and BasisPolynomial::polyRep\&.
.PP
Referenced by RegressOrthogPolyApproximation::dimension_decay_rates(), BasisPolynomial::norm_squared(), and OrthogonalPolynomial::precompute_triple_products()\&.
.SS "const RealArray & collocation_points (unsigned short n)\fC [virtual]\fP"

.PP
return collocation points corresponding to orthogonal polynomial order n This is defined for orthogonal and piecewise interpolation polynomials\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBPiecewiseInterpPolynomial\fP, \fBHermiteInterpPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, and \fBHermiteOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::collocation_points(), and BasisPolynomial::polyRep\&.
.PP
Referenced by IntegrationDriver::assign_1d_collocation_points_weights(), BasisPolynomial::collocation_points(), OrthogonalPolynomial::gauss_check(), NumericGenOrthogPolynomial::hermite_unbounded_integral(), NumericGenOrthogPolynomial::laguerre_semibounded_integral(), NumericGenOrthogPolynomial::legendre_bounded_integral(), and OrthogonalPolynomial::precompute_triple_products()\&.
.SS "const RealArray & type1_collocation_weights (unsigned short order)\fC [virtual]\fP"

.PP
return the type 1 collocation weights corresponding to a point set of size order This is defined for orthogonal and piecewise interpolation polynomials\&. 
.PP
Reimplemented in \fBNumericGenOrthogPolynomial\fP, \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBPiecewiseInterpPolynomial\fP, \fBHermiteInterpPolynomial\fP, \fBLegendreOrthogPolynomial\fP, \fBLaguerreOrthogPolynomial\fP, \fBChebyshevOrthogPolynomial\fP, and \fBHermiteOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type1_collocation_weights()\&.
.PP
Referenced by IntegrationDriver::assign_1d_collocation_points_weights(), OrthogonalPolynomial::gauss_check(), NumericGenOrthogPolynomial::hermite_unbounded_integral(), NumericGenOrthogPolynomial::laguerre_semibounded_integral(), NumericGenOrthogPolynomial::legendre_bounded_integral(), OrthogonalPolynomial::precompute_triple_products(), and BasisPolynomial::type1_collocation_weights()\&.
.SS "const RealArray & type2_collocation_weights (unsigned short order)\fC [virtual]\fP"

.PP
return the type 2 collocation weights corresponding to a point set of size order This is defined for piecewise interpolation polynomials\&. 
.PP
Reimplemented in \fBPiecewiseInterpPolynomial\fP, and \fBHermiteInterpPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::type2_collocation_weights()\&.
.PP
Referenced by IntegrationDriver::assign_1d_collocation_points_weights(), and BasisPolynomial::type2_collocation_weights()\&.
.SS "void reset_gauss ()\fC [virtual]\fP"

.PP
destroy history of Gauss pts/wts (due to distribution parameter changes) This is defined only for orthogonal polynomials\&. 
.PP
Reimplemented in \fBOrthogonalPolynomial\fP\&.
.PP
References BasisPolynomial::polyRep, and BasisPolynomial::reset_gauss()\&.
.PP
Referenced by BasisPolynomial::reset_gauss()\&.
.SS "Real alpha_polynomial () const\fC [virtual]\fP"

.PP
return {Jacobi,GenLaguerre}OrthogPolynomial::alphaPoly This is defined only for parameterized orthogonal polynomials\&. 
.PP
Reimplemented in \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBHahnOrthogPolynomial\fP, \fBMeixnerOrthogPolynomial\fP, \fBKrawtchoukOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::alpha_polynomial(), and BasisPolynomial::polyRep\&.
.PP
Referenced by BasisPolynomial::alpha_polynomial(), CubatureDriver::compute_grid(), and CubatureDriver::grid_size()\&.
.SS "Real beta_polynomial () const\fC [virtual]\fP"

.PP
return \fBJacobiOrthogPolynomial::betaPoly\fP This is defined only for parameterized orthogonal polynomials\&. 
.PP
Reimplemented in \fBJacobiOrthogPolynomial\fP, \fBHahnOrthogPolynomial\fP, \fBMeixnerOrthogPolynomial\fP, and \fBKrawtchoukOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::beta_polynomial(), and BasisPolynomial::polyRep\&.
.PP
Referenced by BasisPolynomial::beta_polynomial(), CubatureDriver::compute_grid(), and CubatureDriver::grid_size()\&.
.SS "void alpha_stat (Real alpha)\fC [virtual]\fP"

.PP
set \fBJacobiOrthogPolynomial::betaPoly\fP or \fBGenLaguerreOrthogPolynomial::alphaPoly\fP from statistical defn of alpha This is defined only for parameterized orthogonal polynomials\&. 
.PP
Reimplemented in \fBJacobiOrthogPolynomial\fP, \fBGenLaguerreOrthogPolynomial\fP, \fBHahnOrthogPolynomial\fP, \fBMeixnerOrthogPolynomial\fP, \fBKrawtchoukOrthogPolynomial\fP, and \fBCharlierOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::alpha_stat(), and BasisPolynomial::polyRep\&.
.PP
Referenced by BasisPolynomial::alpha_stat()\&.
.SS "void beta_stat (Real beta)\fC [virtual]\fP"

.PP
set \fBJacobiOrthogPolynomial::alphaPoly\fP from statistical defn of beta This is defined only for parameterized orthogonal polynomials\&. 
.PP
Reimplemented in \fBJacobiOrthogPolynomial\fP, \fBHahnOrthogPolynomial\fP, \fBMeixnerOrthogPolynomial\fP, and \fBKrawtchoukOrthogPolynomial\fP\&.
.PP
References BasisPolynomial::beta_stat(), and BasisPolynomial::polyRep\&.
.PP
Referenced by BasisPolynomial::beta_stat()\&.
.SS "size_t interpolation_size () const\fC [virtual]\fP"

.PP
get size of \fBInterpolationPolynomial::interpPts\fP This is defined only for interpolation polynomials\&. 
.PP
Reimplemented in \fBInterpolationPolynomial\fP\&.
.PP
References BasisPolynomial::interpolation_size(), and BasisPolynomial::polyRep\&.
.PP
Referenced by SharedNodalInterpPolyApproxData::accumulate_barycentric(), SharedNodalInterpPolyApproxData::accumulate_barycentric_gradient(), SharedNodalInterpPolyApproxData::accumulate_horners(), SharedNodalInterpPolyApproxData::accumulate_horners_gradient(), SharedNodalInterpPolyApproxData::barycentric_exact_index(), BasisPolynomial::interpolation_size(), NodalInterpPolyApproximation::tensor_product_covariance(), NodalInterpPolyApproximation::tensor_product_mean(), NodalInterpPolyApproximation::tensor_product_mean_gradient(), and NodalInterpPolyApproximation::tensor_product_variance_gradient()\&.
.SS "void interpolation_points (const RealArray & interpolation_pts)\fC [virtual]\fP"

.PP
set \fBInterpolationPolynomial::interpPts\fP This is defined only for interpolation polynomials\&. 
.PP
Reimplemented in \fBInterpolationPolynomial\fP\&.
.PP
References BasisPolynomial::interpolation_points(), and BasisPolynomial::polyRep\&.
.PP
Referenced by BasisPolynomial::interpolation_points(), and SharedInterpPolyApproxData::update_interpolation_basis()\&.
.SS "const RealArray & interpolation_points () const\fC [virtual]\fP"

.PP
get \fBInterpolationPolynomial::interpPts\fP This is defined only for interpolation polynomials\&. 
.PP
Reimplemented in \fBInterpolationPolynomial\fP\&.
.PP
References BasisPolynomial::interpolation_points(), and BasisPolynomial::polyRep\&.
.SS "Real factorial (unsigned short n)\fC [inline]\fP, \fC [static]\fP"

.PP
compute n! This implementation is unprotected from overflow, but this should be fine for the polynomial orders that we would expect to encounter\&. Whenever possible, orthogonal polynomial implementations should use \fBfactorial_ratio()\fP or \fBn_choose_k()\fP instead of \fBfactorial()\fP to avoid overflow\&. 
.PP
References BasisPolynomial::factorial_ratio()\&.
.PP
Referenced by HermiteOrthogPolynomial::norm_squared(), GenLaguerreOrthogPolynomial::norm_squared(), JacobiOrthogPolynomial::norm_squared(), HermiteOrthogPolynomial::type1_collocation_weights(), and GenLaguerreOrthogPolynomial::type1_collocation_weights()\&.
.SS "Real factorial_ratio (unsigned short num, unsigned short den)\fC [inline]\fP, \fC [static]\fP"

.PP
compute num!/den! This implementation sequences products in order to minimize the chances of overflow, and its use should be preferred to \fBfactorial()\fP whenever possible\&. 
.PP
Referenced by BasisPolynomial::factorial()\&.
.SS "Real n_choose_k (unsigned short n, unsigned short k)\fC [inline]\fP, \fC [static]\fP"

.PP
compute n!/(k!(n-k)!) Note: n+p choose n or p = (n+p)!/n!/p!
.PP
This implementation sequences products in order to minimize the chances of overflow, and its use should be preferred to \fBfactorial()\fP whenever possible\&. 
.PP
Referenced by CombinedSparseGridDriver::assign_smolyak_arrays(), and SharedPolyApproxData::total_order_terms()\&.
.SS "Real pochhammer (Real m, unsigned short n)\fC [inline]\fP, \fC [static]\fP"

.PP
compute the Pochhammer symbol (m)_n = m*(m+1)\&.\&.\&.*(m+n-1) This is the rising/upper factorial formulation of the Pochhammer symbol (m)_n\&. 
.PP
Referenced by GenLaguerreOrthogPolynomial::norm_squared(), JacobiOrthogPolynomial::norm_squared(), GenLaguerreOrthogPolynomial::type1_collocation_weights(), JacobiOrthogPolynomial::type1_gradient(), JacobiOrthogPolynomial::type1_hessian(), and JacobiOrthogPolynomial::type1_value()\&.
.SS "\fBBasisPolynomial\fP * get_polynomial (short poly_type, short rule)\fC [private]\fP"

.PP
Used by the envelope constructor to initialize polyRep to the appropriate derived type\&. Used only by the envelope constructor to initialize polyRep to the appropriate derived type\&. 
.PP
References BasisPolynomial::basisPolyType\&.
.PP
Referenced by BasisPolynomial::BasisPolynomial()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
