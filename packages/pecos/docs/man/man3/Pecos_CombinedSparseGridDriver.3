.TH "CombinedSparseGridDriver" 3 "Wed Dec 27 2017" "Version Version 1.0" "PECOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CombinedSparseGridDriver \- Derived integration driver class that generates N-dimensional Smolyak sparse grids for numerical evaluation of expectation integrals over independent standard random variables\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBSparseGridDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCombinedSparseGridDriver\fP ()"
.br
.RI "\fIdefault constructor \fP"
.ti -1c
.RI "\fBCombinedSparseGridDriver\fP (unsigned short ssg_level, const RealVector &dim_pref=RealVector(), short \fBgrowth_rate\fP=MODERATE_RESTRICTED_GROWTH, short refine_control=NO_CONTROL)"
.br
.RI "\fIconstructor \fP"
.ti -1c
.RI "\fB~CombinedSparseGridDriver\fP ()"
.br
.RI "\fIdestructor \fP"
.ti -1c
.RI "void \fBcompute_grid\fP (RealMatrix &variable_sets)"
.br
.RI "\fIcompute scaled variable and weight sets for the TPQ grid \fP"
.ti -1c
.RI "int \fBgrid_size\fP ()"
.br
.RI "\fIcompute (if updateGridSize) and return number of collocation points with duplicates removed \fP"
.ti -1c
.RI "void \fBreinterpolated_tensor_grid\fP (const UShortArray &lev_index, const SizetList &reinterp_indices)"
.br
.RI "\fIcomputes and stores data for reinterpolation of covariance on a higher-order tensor grid \fP"
.ti -1c
.RI "void \fBinitialize_grid\fP (const std::vector< \fBBasisPolynomial\fP > &poly_basis)"
.br
.RI "\fIinitialize all sparse grid settings (distribution params already set within poly_basis) \fP"
.ti -1c
.RI "void \fBstore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIstore configuration settings for the current grid before advancing to the next settings within a prescribed grid sequence (default is push_back) \fP"
.ti -1c
.RI "void \fBrestore_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIrestore configuration settings from a previously stored grid \fP"
.ti -1c
.RI "void \fBremove_stored_grid\fP (size_t index=_NPOS)"
.br
.RI "\fIremove configuration settings for a stored grid (default is pop_back) \fP"
.ti -1c
.RI "void \fBclear_stored\fP ()"
.br
.RI "\fIclear stored grid settings following their usage/combination \fP"
.ti -1c
.RI "size_t \fBmaximal_grid\fP () const "
.br
.RI "\fIreturn the index of the maximal stored grid state (_NPOS if the current unstored grid state) \fP"
.ti -1c
.RI "void \fBswap_grid\fP (size_t index)"
.br
.RI "\fIswap settings between the current grid and the stored grid identified by index \fP"
.ti -1c
.RI "void \fBinitialize_sets\fP ()"
.br
.RI "\fIinitializes old/active/evaluation sets for use within the generalized sparse grid procedure \fP"
.ti -1c
.RI "void \fBpush_trial_set\fP (const UShortArray &set)"
.br
.RI "\fIupdate smolyakMultiIndex with a new trial set for use within the generalized sparse grid procedure \fP"
.ti -1c
.RI "void \fBrestore_set\fP ()"
.br
.RI "\fIupdate collocKey, collocIndices, and uniqueIndexMapping based on restoration of previous trial to smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBcompute_trial_grid\fP (RealMatrix &var_sets)"
.br
.RI "\fIcomputes the tensor grid for the index set from \fBpush_trial_set()\fP \fP"
.ti -1c
.RI "void \fBpop_trial_set\fP ()"
.br
.RI "\fIremove the previously pushed trial set from smolyakMultiIndex during the course of the generalized sparse grid procedure \fP"
.ti -1c
.RI "void \fBmerge_set\fP ()"
.br
.RI "\fImerge reference sets with trial set and update reference set \fP"
.ti -1c
.RI "void \fBfinalize_sets\fP (bool output_sets, bool converged_within_tol)"
.br
.RI "\fIaccept all remaining trial sets within the generalized sparse grid procedure \fP"
.ti -1c
.RI "void \fBupdate_reference\fP ()"
.br
.RI "\fIupdate smolyakCoeffsRef and type{1,2}WeightSetsRef for use within the generalized sparse grid procedure \fP"
.ti -1c
.RI "const UShortArray & \fBtrial_set\fP () const "
.br
.RI "\fIreturn trialSet \fP"
.ti -1c
.RI "int \fBunique_trial_points\fP () const "
.br
.RI "\fIreturn num_unique2 \fP"
.ti -1c
.RI "void \fBcompute_grid_increment\fP (RealMatrix &var_sets)"
.br
.RI "\fIcomputes tensor grids for new index sets due to an isotropic/anisotropic refinement \fP"
.ti -1c
.RI "void \fBprint_smolyak_multi_index\fP () const "
.br
.RI "\fIprint smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBinitialize_grid\fP (unsigned short ssg_level, const RealVector &dim_pref, const ShortArray &u_types, const \fBExpansionConfigOptions\fP &ec_options, \fBBasisConfigOptions\fP &bc_options, short \fBgrowth_rate\fP=MODERATE_RESTRICTED_GROWTH, bool track_colloc=false, bool track_uniq_prod_wts=true)"
.br
.RI "\fIinitialize all sparse grid settings except for distribution params \fP"
.ti -1c
.RI "void \fBassign_smolyak_arrays\fP ()"
.br
.RI "\fIoverloaded form initializes smolyakMultiIndex and smolyakCoeffs \fP"
.ti -1c
.RI "void \fBassign_smolyak_arrays\fP (UShort2DArray &multi_index, IntArray &coeffs)"
.br
.RI "\fIinitialize Smolyak multi-index (index sets defining the set of tensor products) and Smolyak combinatorial coefficients using an isotropic or anisotropic index set constraint\&. For anisotropic, webbur::sgmga_vcn_* functions are used to compute index sets satisfying the anisotropic index set constraint, along with their corresponding coefficients\&. \fP"
.ti -1c
.RI "void \fBupdate_smolyak_coefficients\fP (size_t start_index)"
.br
.RI "\fIoverloaded form updates smolyakCoeffs from smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBupdate_smolyak_coefficients\fP (size_t start_index, const UShort2DArray &multi_index, IntArray &coeffs)"
.br
.RI "\fIupdate the coeffs array based on new trailing index sets within multi_index for incrementally generated generalized sparse grids \fP"
.ti -1c
.RI "void \fBassign_collocation_key\fP ()"
.br
.RI "\fIinitialize collocKey from smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBupdate_collocation_key\fP (size_t start_index)"
.br
.RI "\fIupdate collocKey for the trailing index sets within smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBassign_collocation_indices\fP ()"
.br
.RI "\fIinitialize collocIndices from collocKey and uniqueIndexMapping \fP"
.ti -1c
.RI "void \fBreference_unique\fP (RealMatrix &var_sets)"
.br
.RI "\fIdefine a1{Points,Type1Weights,Type2Weights} based on the reference grid \fP"
.ti -1c
.RI "void \fBincrement_unique\fP (bool compute_a2, bool \fBupdate_sets\fP, RealMatrix &var_sets)"
.br
.RI "\fIdefine a2Points and update collocIndices and uniqueIndexMapping for the trailing index set within smolyakMultiIndex \fP"
.ti -1c
.RI "void \fBmerge_unique\fP ()"
.br
.RI "\fIupdate a1Points by merging with unique a2Points \fP"
.ti -1c
.RI "void \fBfinalize_unique\fP (size_t start_index)"
.br
.RI "\fIapply all remaining trial sets \fP"
.ti -1c
.RI "void \fBcompute_tensor_points_weights\fP (size_t start_index, size_t num_indices, RealMatrix &pts, RealVector &t1_wts, RealMatrix &t2_wts)"
.br
.ti -1c
.RI "void \fBassign_tensor_collocation_indices\fP (size_t start_index, const IntArray &unique_index)"
.br
.ti -1c
.RI "const UShort2DArray & \fBsmolyak_multi_index\fP () const "
.br
.RI "\fIreturn smolyakMultiIndex \fP"
.ti -1c
.RI "const IntArray & \fBsmolyak_coefficients\fP () const "
.br
.RI "\fIreturn smolyakCoeffs \fP"
.ti -1c
.RI "const IntArray & \fBsmolyak_coefficients_reference\fP () const "
.br
.RI "\fIreturn smolyakCoeffsRef \fP"
.ti -1c
.RI "void \fBtrack_collocation_details\fP (bool track_colloc)"
.br
.RI "\fIset trackCollocDetails \fP"
.ti -1c
.RI "bool \fBtrack_collocation_details\fP () const "
.br
.RI "\fIget trackCollocDetails \fP"
.ti -1c
.RI "void \fBtrack_unique_product_weights\fP (bool track_uniq_prod_wts)"
.br
.RI "\fIset trackUniqueProdWeights \fP"
.ti -1c
.RI "bool \fBtrack_unique_product_weights\fP () const "
.br
.RI "\fIget trackUniqueProdWeights \fP"
.ti -1c
.RI "const UShort3DArray & \fBcollocation_key\fP () const "
.br
.RI "\fIreturn collocKey \fP"
.ti -1c
.RI "const Sizet2DArray & \fBcollocation_indices\fP () const "
.br
.RI "\fIreturn collocIndices \fP"
.ti -1c
.RI "const IntArray & \fBunique_index_mapping\fP () const "
.br
.RI "\fIreturn uniqueIndexMapping \fP"
.ti -1c
.RI "const UShort2DArray & \fBstored_smolyak_multi_index\fP (size_t index) const "
.br
.RI "\fIreturn storedLevMultiIndex[index] \fP"
.ti -1c
.RI "const IntArray & \fBstored_smolyak_coefficients\fP (size_t index) const "
.br
.RI "\fIreturn storedLevCoeffs[index] \fP"
.ti -1c
.RI "const UShort3DArray & \fBstored_collocation_key\fP (size_t index) const "
.br
.RI "\fIreturn storedCollocKey[index] \fP"
.ti -1c
.RI "const Sizet2DArray & \fBstored_collocation_indices\fP (size_t index) const "
.br
.RI "\fIreturn storedCollocIndices[index] \fP"
.ti -1c
.RI "const RealVector & \fBtype1_weight_sets\fP () const "
.br
.RI "\fIreturn type1WeightSets \fP"
.ti -1c
.RI "const RealMatrix & \fBtype2_weight_sets\fP () const "
.br
.RI "\fIreturn type2WeightSets \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdate_sparse_points\fP (size_t start_index, int new_index_offset, const RealMatrix &tensor_pts, const BitArray &is_unique, const IntArray &unique_index, RealMatrix &new_sparse_pts)"
.br
.RI "\fIconvenience function for updating sparse points from a set of aggregated tensor points \fP"
.ti -1c
.RI "void \fBupdate_sparse_weights\fP (size_t start_index, const RealVector &tensor_t1_wts, const RealMatrix &tensor_t2_wts, const IntArray &unique_index, RealVector &updated_t1_wts, RealMatrix &updated_t2_wts)"
.br
.RI "\fIconvenience function for updating sparse weights from a set of aggregated tensor weights \fP"
.ti -1c
.RI "void \fBinitialize_duplicate_tolerance\fP ()"
.br
.RI "\fIset duplicateTol based on the content of collocRules: table lookups will generally be more precise/repeatable than numerically-generated rules \fP"
.ti -1c
.RI "void \fBinitialize_rule_pointers\fP ()"
.br
.RI "\fIinitialize compute1D{Points,Type1Weights,Type2Weights} function pointer arrays for use within webbur::sgmg() and webbur::sgmga() routines \fP"
.ti -1c
.RI "void \fBinitialize_growth_pointers\fP ()"
.br
.RI "\fIinitialize levelGrowthToOrder function pointer arrays for use within webbur::sgmg() and webbur::sgmga() routines \fP"
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static void \fBbasis_collocation_points\fP (int order, int index, double *data)"
.br
.RI "\fIfunction passed by pointer for computing collocation points for polynomialBasis[index] \fP"
.ti -1c
.RI "static void \fBbasis_type1_collocation_weights\fP (int order, int index, double *data)"
.br
.RI "\fIfunction passed by pointer for computing type 1 collocation weights for polynomialBasis[index] \fP"
.ti -1c
.RI "static void \fBbasis_type2_collocation_weights\fP (int order, int index, double *data)"
.br
.RI "\fIfunction passed by pointer for computing type 2 collocation weights for polynomialBasis[index] \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "UShort2DArray \fBsmolyakMultiIndex\fP"
.br
.RI "\fInumSmolyakIndices-by-numVars array for identifying the index to use within the polynomialBasis for a particular variable \fP"
.ti -1c
.RI "IntArray \fBsmolyakCoeffs\fP"
.br
.RI "\fIarray of Smolyak combinatorial coefficients, one for each tensor product index set; order is synchronized with smolyakMultiIndex \fP"
.ti -1c
.RI "IntArray \fBsmolyakCoeffsRef\fP"
.br
.RI "\fIreference values for the Smolyak combinatorial coefficients; used in incremental approaches that update smolyakCoeffs \fP"
.ti -1c
.RI "bool \fBtrackCollocDetails\fP"
.br
.RI "\fIflag controls conditional population of collocKey, collocIndices, collocPts1D and type{1,2}CollocWts1D \fP"
.ti -1c
.RI "bool \fBtrackUniqueProdWeights\fP"
.br
.RI "\fIflag indicating need to track {type1,type2}WeightSets (product weights for each unique grid point) as opposed to relying on collections of 1D weights \fP"
.ti -1c
.RI "UShort3DArray \fBcollocKey\fP"
.br
.RI "\fInumSmolyakIndices-by-numTensorProductPts-by-numVars array for identifying the 1-D point indices for sets of tensor-product collocation points \fP"
.ti -1c
.RI "Sizet2DArray \fBcollocIndices\fP"
.br
.RI "\fInumSmolyakIndices-by-numTensorProductPts array for linking the set of tensor products to the unique collocation points evaluated \fP"
.ti -1c
.RI "UShortArray \fBtrialSet\fP"
.br
.RI "\fItrial evaluation set from \fBpush_trial_set()\fP \fP"
.ti -1c
.RI "UShort3DArray \fBstoredLevMultiIndex\fP"
.br
.RI "\fIstored driver states: copies of smolyakMultiIndex \fP"
.ti -1c
.RI "Int2DArray \fBstoredLevCoeffs\fP"
.br
.RI "\fIstored driver states: copies of smolyakCoeffs \fP"
.ti -1c
.RI "UShort4DArray \fBstoredCollocKey\fP"
.br
.RI "\fIstored driver states: copies of collocKey \fP"
.ti -1c
.RI "Sizet3DArray \fBstoredCollocIndices\fP"
.br
.RI "\fIstored driver states: copies of collocIndices \fP"
.ti -1c
.RI "RealVector \fBtype1WeightSets\fP"
.br
.RI "\fIthe set of type1 weights (for integration of value interpolants) associated with each point in the sparse grid \fP"
.ti -1c
.RI "RealMatrix \fBtype2WeightSets\fP"
.br
.RI "\fIthe set of type2 weights (for integration of gradient interpolants) for each derivative component and for each point in the sparse grid \fP"
.ti -1c
.RI "RealVector \fBtype1WeightSetsRef\fP"
.br
.RI "\fIreference values for the type1 weights corresponding to the current reference grid; used in incremental approaches that update type1WeightSets \fP"
.ti -1c
.RI "RealMatrix \fBtype2WeightSetsRef\fP"
.br
.RI "\fIreference values for the type2 weights corresponding to the current reference grid; used in incremental approaches that update type2WeightSets \fP"
.ti -1c
.RI "RealVectorArray \fBstoredType1WeightSets\fP"
.br
.RI "\fIstored driver states: copies of type1WeightSets \fP"
.ti -1c
.RI "RealMatrixArray \fBstoredType2WeightSets\fP"
.br
.RI "\fIstored driver states: copies of type2WeightSets \fP"
.ti -1c
.RI "std::vector< CollocFnPtr > \fBcompute1DPoints\fP"
.br
.RI "\fIarray of pointers to collocation point evaluation functions \fP"
.ti -1c
.RI "std::vector< CollocFnPtr > \fBcompute1DType1Weights\fP"
.br
.RI "\fIarray of pointers to type1 collocation weight evaluation functions \fP"
.ti -1c
.RI "std::vector< LevGrwOrdFnPtr > \fBlevelGrowthToOrder\fP"
.br
.RI "\fIarray of pointers to webbur::level_to_growth functions \fP"
.ti -1c
.RI "IntArray \fBuniqueIndexMapping\fP"
.br
.RI "\fIoutput from sgmga_unique_index() \fP"
.ti -1c
.RI "Real \fBduplicateTol\fP"
.br
.RI "\fIduplication tolerance used in sgmga routines \fP"
.ti -1c
.RI "int \fBnumUnique1\fP"
.br
.RI "\fInumber of unique points in set 1 (reference) \fP"
.ti -1c
.RI "int \fBnumUnique2\fP"
.br
.RI "\fInumber of unique points in set 2 (increment) \fP"
.ti -1c
.RI "RealVector \fBzVec\fP"
.br
.RI "\fIrandom vector used within sgmgg for sorting \fP"
.ti -1c
.RI "RealVector \fBr1Vec\fP"
.br
.RI "\fIdistance values for sorting in set 1 (reference) \fP"
.ti -1c
.RI "RealVector \fBr2Vec\fP"
.br
.RI "\fIdistance values for sorting in set 2 (increment) \fP"
.ti -1c
.RI "RealMatrix \fBa1Points\fP"
.br
.RI "\fIarray of collocation points in set 1 (reference) \fP"
.ti -1c
.RI "RealMatrix \fBa2Points\fP"
.br
.RI "\fIarray of collocation points in set 2 (increment) \fP"
.ti -1c
.RI "RealVector \fBa1Type1Weights\fP"
.br
.RI "\fIvector of type1 weights in set 1 (reference) \fP"
.ti -1c
.RI "RealMatrix \fBa1Type2Weights\fP"
.br
.RI "\fImatrix of type2 weights in set 1 (reference) \fP"
.ti -1c
.RI "RealVector \fBa2Type1Weights\fP"
.br
.RI "\fIvector of type1 weights in set 2 (increment) \fP"
.ti -1c
.RI "RealMatrix \fBa2Type2Weights\fP"
.br
.RI "\fImatrix of type2 weights in set 2 (increment) \fP"
.ti -1c
.RI "IntArray \fBsortIndex1\fP"
.br
.RI "\fIascending sort index for set 1 (reference) \fP"
.ti -1c
.RI "IntArray \fBsortIndex2\fP"
.br
.RI "\fIascending sort index for set 2 (increment) \fP"
.ti -1c
.RI "IntArray \fBuniqueSet1\fP"
.br
.RI "\fIindex within a1 (reference set) of unique points \fP"
.ti -1c
.RI "IntArray \fBuniqueSet2\fP"
.br
.RI "\fIindex within a2 (increment set) of unique points \fP"
.ti -1c
.RI "IntArray \fBuniqueIndex1\fP"
.br
.RI "\fIindex within uniqueSet1 corresponding to all of a1 \fP"
.ti -1c
.RI "IntArray \fBuniqueIndex2\fP"
.br
.RI "\fIindex within uniqueSet2 corresponding to all of a2 \fP"
.ti -1c
.RI "BitArray \fBisUnique1\fP"
.br
.RI "\fIkey to unique points in set 1 (reference) \fP"
.ti -1c
.RI "BitArray \fBisUnique2\fP"
.br
.RI "\fIkey to unique points in set 2 (increment) \fP"
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBCombinedSparseGridDriver\fP * \fBsgdInstance\fP"
.br
.RI "\fIpointer to instance of this class for use in static member functions \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Derived integration driver class that generates N-dimensional Smolyak sparse grids for numerical evaluation of expectation integrals over independent standard random variables\&. 

This class is used by Dakota::NonDSparseGrid, but could also be used for general numerical integration of moments\&. It employs 1-D Clenshaw-Curtis, Newton-Cotes, and Gaussian quadrature rules within Smolyak sparse grids\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fBCombinedSparseGridDriver\fP * sgdInstance\fC [static]\fP, \fC [private]\fP"

.PP
pointer to instance of this class for use in static member functions initialize static member pointer to active driver instance 
.PP
Referenced by CombinedSparseGridDriver::basis_collocation_points(), CombinedSparseGridDriver::basis_type1_collocation_weights(), CombinedSparseGridDriver::basis_type2_collocation_weights(), CombinedSparseGridDriver::compute_grid(), and CombinedSparseGridDriver::grid_size()\&.
.SS "UShort2DArray smolyakMultiIndex\fC [private]\fP"

.PP
numSmolyakIndices-by-numVars array for identifying the index to use within the polynomialBasis for a particular variable The index sets correspond to j (0-based) for use as indices, which are offset from the i indices (1-based) normally used in the Smolyak expressions\&. The indices correspond to levels, one for each anisotropic tensor-product grid within a Smolyak recursion\&. 
.PP
Referenced by CombinedSparseGridDriver::assign_collocation_key(), CombinedSparseGridDriver::assign_smolyak_arrays(), CombinedSparseGridDriver::finalize_sets(), CombinedSparseGridDriver::finalize_unique(), CombinedSparseGridDriver::increment_unique(), CombinedSparseGridDriver::initialize_sets(), CombinedSparseGridDriver::pop_trial_set(), CombinedSparseGridDriver::print_smolyak_multi_index(), CombinedSparseGridDriver::push_trial_set(), CombinedSparseGridDriver::reference_unique(), CombinedSparseGridDriver::restore_grid(), CombinedSparseGridDriver::restore_set(), CombinedSparseGridDriver::smolyak_multi_index(), CombinedSparseGridDriver::store_grid(), CombinedSparseGridDriver::swap_grid(), CombinedSparseGridDriver::update_collocation_key(), CombinedSparseGridDriver::update_smolyak_coefficients(), CombinedSparseGridDriver::update_sparse_points(), and CombinedSparseGridDriver::update_sparse_weights()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for PECOS from the source code\&.
